import{S as ds,i as ms,s as ys,w as ya,a as ks,d as ws,m as bs,x as vs,y as ss,n as gs,t as _s,o as Es,z as ns,q as l,A as o,b as c,r,B as p,C as i,g as t,f as u,u as _,F as Is,E as xs,j as n,k as a,p as Ps}from"./index-58f43e7f.js";import{B as Ts}from"./blog-d7f7866c.js";function Ks($){let h,w,b,v,f,y,E,lt,ge,W,rt,_e,z,pt,Ee,D,ct,Ie,L,ut,xe,R,ht,Pe,N,ft,Te,U,dt,Ke,x,mt,ie,yt,kt,je,J,wt,Ce,V,bt,Me,Y,vt,Ae,A,is=`<code class="language-ts">fun <span class="token function">first</span><span class="token punctuation">(</span>l<span class="token operator">:</span> list<span class="token operator">&lt;</span>a<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">match</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Cons</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> head
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</code>`,Be,F,gt,Se,P,_t,le,Et,It,He,d,xt,re,Pt,Tt,pe,Kt,jt,ce,Ct,Mt,ue,At,Bt,he,St,Ht,qe,B,ls=`<code class="language-ts">fun <span class="token function">dumb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> either<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> nirvana<span class="token operator">></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">with</span> control <span class="token function">raise</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token string">"Why did you think that would work?"</span><span class="token punctuation">.</span>Left<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
  <span class="token function">first</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">.</span>Right
<span class="token punctuation">&#125;</span></code>`,Oe,T,qt,fe,Ot,$t,$e,G,Wt,We,K,zt,de,Dt,Lt,ze,S,rs=`<code class="language-ts">effect val postgres <span class="token operator">:</span> dbConnection

fun <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> postgres <span class="token punctuation">&#123;</span>
  <span class="token operator">...</span><span class="token punctuation">.</span> <span class="token comment">// arbitrary use of postgres at any depth as a value internally</span>
<span class="token punctuation">&#125;</span>

fun <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">with</span> val postgres <span class="token operator">=</span> realConnection
  <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

fun <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">with</span> val postgres <span class="token operator">=</span> testMock
  <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,De,Z,Rt,Le,Q,Nt,Re,X,Ut,Ne,j,Jt,me,Vt,Yt,Ue,H,ps=`<code class="language-ts">fun <span class="token keyword">while</span><span class="token punctuation">(</span> predicate <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&lt;</span>div<span class="token operator">|</span>e<span class="token operator">></span> bool<span class="token punctuation">,</span> action <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&lt;</span>div<span class="token operator">|</span>e<span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">&lt;</span>div<span class="token operator">|</span>e<span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">predicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> action<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">while</span> <span class="token punctuation">&#123;</span>condition <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm secretly functional!"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Je,m,ye,Ft,Gt,ke,Zt,Qt,we,Xt,ea,be,ta,aa,Ve,ee,sa,Ye,te,na,Fe,ae,oa,Ge,se,ia,Ze,g,la,q,ra,pa,O,ca,ua,Qe,C,ka,Xe,ne,ha,et,M,fa,ve,da,ma;return{c(){h=l("p"),w=o("I love statically typed functional programming. Building up programs in statically typed functional style feels like a conversation with the compiler about what is possible."),b=c(),v=l("p"),f=o("Python fanatics tell me over and over that you can’t prototype that way. Unfortunately, heartbreakingly, sometimes they’re right."),y=c(),E=l("h2"),lt=o("Prototyping"),ge=c(),W=l("p"),rt=o("Sometimes it is much easier to get to a useful product if you accept that you don’t understand how it works in an edge case. I wanted a compiler that could say “I can work with this, but you should clean it up later”. I didn’t found one."),_e=c(),z=l("h2"),pt=o("Postgres"),Ee=c(),D=l("p"),ct=o("Sometimes you need to interact with complicated, outside resources like databases, and purity feels like a fools errand. I wanted a compiler that would let me compose with impunity, but still remember that somewhere in the program I need to give it a database. I didn’t found one."),Ie=c(),L=l("h2"),ut=o("Performance"),xe=c(),R=l("p"),ht=o("This has become somewhat less important now that the frame of reference for a lot of people is javascript and python rather than C, but functional languages can perform quite badly and use a lot of memory because they want everything to be immutable. I wanted a compiler that could take nice functional code and rewrite it based on the context to be performant and imperative, but somewhere I didn’t have to see it. I didn’t find one."),Pe=c(),N=l("h2"),ft=o("Preferences"),Te=c(),U=l("p"),dt=o("Sometimes you have someone on your team who has the same love of mutable state that I have of static types and function composition. I wanted a compiler that could let them have their fun, but create clean, tight barriers around mutations so that I could see from the type whether or not I had to deal with that nonsense. I didn’t find one."),Ke=c(),x=l("p"),mt=o("I did not expect these problems to have the same solution. I thought these were unrelated flaws of the languages I loved, and that the only solution was to work in multiparadigm languages and be "),ie=l("em"),yt=o("very very careful"),kt=o(" because I could never quite trust the types. I figured that if the problem were solvable, someone would have solved it in the last 47 years of research."),je=c(),J=l("p"),wt=o("Then a friend showed me Koka."),Ce=c(),V=l("h2"),bt=o("Effect Types for Prototyping"),Me=c(),Y=l("p"),vt=o("The first thing I saw reading about Koka was that it had exceptions, and I almost gave up there. Exceptions are the biggest footgun that I have to worry about on a daily basis. Seeing them in a nice pure language I felt cheated and lied to. But in Koka, something is different when you throw an exception; it is captured in the type."),Ae=c(),A=l("pre"),Be=c(),F=l("p"),gt=o("This code takes a list and gives back its first element. There are cleaner ways to do this, but for illustration I wanted to write it out fully."),Se=c(),P=l("p"),_t=o("In most functional languages, this wouldn’t compile. “That pattern matching isn’t complete”, they would say. “What if you got an empty list?” they would say. So programmers, not able to explain to the compiler that they are "),le=l("em"),Et=o("absolutely certain"),It=o(" that won’t happen, switch away from such languages to something a little more practical (typescript) and just let the code throw."),He=c(),d=l("p"),xt=o("Everybody lives happily ever after, until this prototyping code is embedded in the core of a Very Important Model being used in production, and it actually does get an empty list because the code has been rewritten half a dozen times since the programmer was "),re=l("em"),Pt=o("absolutely certain"),Tt=o(" that couldn’t happen. But in Koka, unlike in typescript, the return type of this function "),pe=l("em"),Kt=o("remembers"),jt=o(" that there can be an exception. The return type here is inferred as "),ce=l("code"),Ct=o("exn a"),Mt=o(" rather than just "),ue=l("code"),At=o("a"),Bt=o(". Any function calling this also gets that "),he=l("code"),St=o("exn"),Ht=o(" effect added to its type, until the programmer goes back and deals with that effect and removes it everywhere or catches it with an effect handler."),qe=c(),B=l("pre"),Oe=c(),T=l("p"),qt=o("Now anything calling "),fe=l("code"),Ot=o("dumb"),$t=o(" can be certain that the exception was handled, and doesn’t need to worry about it anymore. This gives us a clean way to iteratively integrate prototype code into a production codebase, by looking at the type and controlling for unknowns or rewriting to rule them out."),$e=c(),G=l("h2"),Wt=o("Effect Types for Postgres"),We=c(),K=l("p"),zt=o("I was sold. You could write exceptional code and prototype away, and clean up after yourself later. I figured that was it, that was the clever trick for this language, but effect types are "),de=l("em"),Dt=o("so much better than that"),Lt=o(". Effects aren’t limited to those defined in the language, you can make up your own in user land. This means that I can write an effect like this;"),ze=c(),S=l("pre"),De=c(),Z=l("p"),Rt=o("This is dependency injection, but without any of the horrible nonsense of passing dependencies down all the way through the application or currying everywhere to create versions of services with the dependency in the closure. Any function can say “I need access to the database” by declaring the effect, and Koka handles the rest. This magic is actually the same semantic that Koka used to define exceptions, restricted to the case where the result of the effect was always a single value. And even better, while real database connections probably have all sorts of gross side effects, this injection can be polymorphic over the effect to let us be sure that our code in the test case can stay pure and deterministic."),Le=c(),Q=l("h2"),Nt=o("Effect Types (and Trailing Lambdas) for Preferences"),Re=c(),X=l("p"),Ut=o("Alright, that’s it then. Effect types solve the prototyping problem, and give a beautiful new pattern for dependency injection. What more can we ask for?"),Ne=c(),j=l("p"),Jt=o("One of the biggest barriers that functional languages face is just about what people already know. Programmers want to write loops because they are used to loops, and it doesn’t matter if there is an equivalent functional program; if they aren’t used to it it will be harder to debug and not worth their time. But Koka "),me=l("em"),Vt=o("has"),Yt=o(" while loops. And they are functions, defined in user land."),Ue=c(),H=l("pre"),Je=c(),m=l("p"),ye=l("code"),Ft=o("while"),Gt=o(" here is just a function, with Koka providing a bunch of syntactic sugar to make the way you call it more familiar to those comfortable in imperative languages. The fact that it’s still a function means that all of the composable semantics that we get out of effect types and function composition still apply to code using loops of this form, even though the code looks dirty and imperative. Even the infinite loop here is captured by the type system. Koka infers that anything using this function has the "),ke=l("code"),Zt=o("div"),Qt=o(" effect, meaning it might run forever without producing a value. This is the same effect it would infer for a recursive function, because "),we=l("code"),Xt=o("while"),ea=c(),be=l("em"),ta=o("is"),aa=o(" a recursive function."),Ve=c(),ee=l("p"),sa=o("This effort to preserve the intuition of developers coming from imperative languages extends way beyond fake looping constructs. It should say something that while I couldn’t find a syntax highlighter for koka to use on these code blocks, the javascript syntax highlighting looks pretty much fine. The language as a whole is designed to feel familiar to people used to C family syntax, but give superpowers that nothing in that family has."),Ye=c(),te=l("h2"),na=o("No Compromises"),Fe=c(),ae=l("p"),oa=o("Usually, having discovered something beautiful and powerful that checks so many boxes, the cost is performance. Asking computers to do something so completely unrelated to their memory model is expensive, and so such languages usually come with bloated, slow runtimes that do the translation at the last possible minute. Sometimes, very clever compilers do things like tail call optimization to take common functional patterns and statically transform them into loops, but that can only go so far. While the nice tricks Koka is playing to give us mutable variables look like they do in-place updates, they still desugar to slow, piggy functions."),Ge=c(),se=l("p"),ia=o("Just kidding. They become stupid fast in-place updates with no need for a garbage collector."),Ze=c(),g=l("p"),la=o("Koka does transform those mutable variables into a state effect to make sure to have all of the wonderful functional semantics that help us keep code composable, but it also uses the "),q=l("a"),ra=o("Perceus"),pa=o(" compiler to transform that state effect into in-place updates wherever possible. Reuse analysis is even more powerful, taking clean functional expressions like list maps or tree traversals and transforming them into in-place mutations whenever possible, gracefully degrading back to shared memory persistent representations when not. The "),O=l("a"),ca=o("Koka book"),ua=o(" explains this much better than I can, but it is worth glancing at the benchmarks they’ve done so far."),Qe=c(),C=l("img"),Xe=c(),ne=l("p"),ha=o("This unfinished research language can outperform C++. Benchmarks should always be taken with an ocean of salt, and these problems certainly weren’t chosen at random, but the firm foundation of Perceus gives me hope that these results are real and will be borne out in practice."),et=c(),M=l("p"),fa=o("It is early days for Koka. It isn’t ready for production, and new languages usually aren’t adopted, but there is "),ve=l("em"),da=o("so"),ma=o(" much in Koka that is fundamentally better than existing languages that I would be heartbroken if these things didn’t catch on. Maybe it is a stepping stone, and something else will productionalize these ideas, but it is hard to imagine changing very much. Koka improves on the state of the art in so many places that it feels to me like making it productional is the path forward, rather than adopting these ideas into other languages."),this.h()},l(e){h=r(e,"P",{});var s=p(h);w=i(s,"I love statically typed functional programming. Building up programs in statically typed functional style feels like a conversation with the compiler about what is possible."),s.forEach(t),b=u(e),v=r(e,"P",{});var wa=p(v);f=i(wa,"Python fanatics tell me over and over that you can’t prototype that way. Unfortunately, heartbreakingly, sometimes they’re right."),wa.forEach(t),y=u(e),E=r(e,"H2",{});var ba=p(E);lt=i(ba,"Prototyping"),ba.forEach(t),ge=u(e),W=r(e,"P",{});var va=p(W);rt=i(va,"Sometimes it is much easier to get to a useful product if you accept that you don’t understand how it works in an edge case. I wanted a compiler that could say “I can work with this, but you should clean it up later”. I didn’t found one."),va.forEach(t),_e=u(e),z=r(e,"H2",{});var ga=p(z);pt=i(ga,"Postgres"),ga.forEach(t),Ee=u(e),D=r(e,"P",{});var _a=p(D);ct=i(_a,"Sometimes you need to interact with complicated, outside resources like databases, and purity feels like a fools errand. I wanted a compiler that would let me compose with impunity, but still remember that somewhere in the program I need to give it a database. I didn’t found one."),_a.forEach(t),Ie=u(e),L=r(e,"H2",{});var Ea=p(L);ut=i(Ea,"Performance"),Ea.forEach(t),xe=u(e),R=r(e,"P",{});var Ia=p(R);ht=i(Ia,"This has become somewhat less important now that the frame of reference for a lot of people is javascript and python rather than C, but functional languages can perform quite badly and use a lot of memory because they want everything to be immutable. I wanted a compiler that could take nice functional code and rewrite it based on the context to be performant and imperative, but somewhere I didn’t have to see it. I didn’t find one."),Ia.forEach(t),Pe=u(e),N=r(e,"H2",{});var xa=p(N);ft=i(xa,"Preferences"),xa.forEach(t),Te=u(e),U=r(e,"P",{});var Pa=p(U);dt=i(Pa,"Sometimes you have someone on your team who has the same love of mutable state that I have of static types and function composition. I wanted a compiler that could let them have their fun, but create clean, tight barriers around mutations so that I could see from the type whether or not I had to deal with that nonsense. I didn’t find one."),Pa.forEach(t),Ke=u(e),x=r(e,"P",{});var tt=p(x);mt=i(tt,"I did not expect these problems to have the same solution. I thought these were unrelated flaws of the languages I loved, and that the only solution was to work in multiparadigm languages and be "),ie=r(tt,"EM",{});var Ta=p(ie);yt=i(Ta,"very very careful"),Ta.forEach(t),kt=i(tt," because I could never quite trust the types. I figured that if the problem were solvable, someone would have solved it in the last 47 years of research."),tt.forEach(t),je=u(e),J=r(e,"P",{});var Ka=p(J);wt=i(Ka,"Then a friend showed me Koka."),Ka.forEach(t),Ce=u(e),V=r(e,"H2",{});var ja=p(V);bt=i(ja,"Effect Types for Prototyping"),ja.forEach(t),Me=u(e),Y=r(e,"P",{});var Ca=p(Y);vt=i(Ca,"The first thing I saw reading about Koka was that it had exceptions, and I almost gave up there. Exceptions are the biggest footgun that I have to worry about on a daily basis. Seeing them in a nice pure language I felt cheated and lied to. But in Koka, something is different when you throw an exception; it is captured in the type."),Ca.forEach(t),Ae=u(e),A=r(e,"PRE",{class:!0});var cs=p(A);cs.forEach(t),Be=u(e),F=r(e,"P",{});var Ma=p(F);gt=i(Ma,"This code takes a list and gives back its first element. There are cleaner ways to do this, but for illustration I wanted to write it out fully."),Ma.forEach(t),Se=u(e),P=r(e,"P",{});var at=p(P);_t=i(at,"In most functional languages, this wouldn’t compile. “That pattern matching isn’t complete”, they would say. “What if you got an empty list?” they would say. So programmers, not able to explain to the compiler that they are "),le=r(at,"EM",{});var Aa=p(le);Et=i(Aa,"absolutely certain"),Aa.forEach(t),It=i(at," that won’t happen, switch away from such languages to something a little more practical (typescript) and just let the code throw."),at.forEach(t),He=u(e),d=r(e,"P",{});var k=p(d);xt=i(k,"Everybody lives happily ever after, until this prototyping code is embedded in the core of a Very Important Model being used in production, and it actually does get an empty list because the code has been rewritten half a dozen times since the programmer was "),re=r(k,"EM",{});var Ba=p(re);Pt=i(Ba,"absolutely certain"),Ba.forEach(t),Tt=i(k," that couldn’t happen. But in Koka, unlike in typescript, the return type of this function "),pe=r(k,"EM",{});var Sa=p(pe);Kt=i(Sa,"remembers"),Sa.forEach(t),jt=i(k," that there can be an exception. The return type here is inferred as "),ce=r(k,"CODE",{});var Ha=p(ce);Ct=i(Ha,"exn a"),Ha.forEach(t),Mt=i(k," rather than just "),ue=r(k,"CODE",{});var qa=p(ue);At=i(qa,"a"),qa.forEach(t),Bt=i(k,". Any function calling this also gets that "),he=r(k,"CODE",{});var Oa=p(he);St=i(Oa,"exn"),Oa.forEach(t),Ht=i(k," effect added to its type, until the programmer goes back and deals with that effect and removes it everywhere or catches it with an effect handler."),k.forEach(t),qe=u(e),B=r(e,"PRE",{class:!0});var us=p(B);us.forEach(t),Oe=u(e),T=r(e,"P",{});var st=p(T);qt=i(st,"Now anything calling "),fe=r(st,"CODE",{});var $a=p(fe);Ot=i($a,"dumb"),$a.forEach(t),$t=i(st," can be certain that the exception was handled, and doesn’t need to worry about it anymore. This gives us a clean way to iteratively integrate prototype code into a production codebase, by looking at the type and controlling for unknowns or rewriting to rule them out."),st.forEach(t),$e=u(e),G=r(e,"H2",{});var Wa=p(G);Wt=i(Wa,"Effect Types for Postgres"),Wa.forEach(t),We=u(e),K=r(e,"P",{});var nt=p(K);zt=i(nt,"I was sold. You could write exceptional code and prototype away, and clean up after yourself later. I figured that was it, that was the clever trick for this language, but effect types are "),de=r(nt,"EM",{});var za=p(de);Dt=i(za,"so much better than that"),za.forEach(t),Lt=i(nt,". Effects aren’t limited to those defined in the language, you can make up your own in user land. This means that I can write an effect like this;"),nt.forEach(t),ze=u(e),S=r(e,"PRE",{class:!0});var hs=p(S);hs.forEach(t),De=u(e),Z=r(e,"P",{});var Da=p(Z);Rt=i(Da,"This is dependency injection, but without any of the horrible nonsense of passing dependencies down all the way through the application or currying everywhere to create versions of services with the dependency in the closure. Any function can say “I need access to the database” by declaring the effect, and Koka handles the rest. This magic is actually the same semantic that Koka used to define exceptions, restricted to the case where the result of the effect was always a single value. And even better, while real database connections probably have all sorts of gross side effects, this injection can be polymorphic over the effect to let us be sure that our code in the test case can stay pure and deterministic."),Da.forEach(t),Le=u(e),Q=r(e,"H2",{});var La=p(Q);Nt=i(La,"Effect Types (and Trailing Lambdas) for Preferences"),La.forEach(t),Re=u(e),X=r(e,"P",{});var Ra=p(X);Ut=i(Ra,"Alright, that’s it then. Effect types solve the prototyping problem, and give a beautiful new pattern for dependency injection. What more can we ask for?"),Ra.forEach(t),Ne=u(e),j=r(e,"P",{});var ot=p(j);Jt=i(ot,"One of the biggest barriers that functional languages face is just about what people already know. Programmers want to write loops because they are used to loops, and it doesn’t matter if there is an equivalent functional program; if they aren’t used to it it will be harder to debug and not worth their time. But Koka "),me=r(ot,"EM",{});var Na=p(me);Vt=i(Na,"has"),Na.forEach(t),Yt=i(ot," while loops. And they are functions, defined in user land."),ot.forEach(t),Ue=u(e),H=r(e,"PRE",{class:!0});var fs=p(H);fs.forEach(t),Je=u(e),m=r(e,"P",{});var I=p(m);ye=r(I,"CODE",{});var Ua=p(ye);Ft=i(Ua,"while"),Ua.forEach(t),Gt=i(I," here is just a function, with Koka providing a bunch of syntactic sugar to make the way you call it more familiar to those comfortable in imperative languages. The fact that it’s still a function means that all of the composable semantics that we get out of effect types and function composition still apply to code using loops of this form, even though the code looks dirty and imperative. Even the infinite loop here is captured by the type system. Koka infers that anything using this function has the "),ke=r(I,"CODE",{});var Ja=p(ke);Zt=i(Ja,"div"),Ja.forEach(t),Qt=i(I," effect, meaning it might run forever without producing a value. This is the same effect it would infer for a recursive function, because "),we=r(I,"CODE",{});var Va=p(we);Xt=i(Va,"while"),Va.forEach(t),ea=u(I),be=r(I,"EM",{});var Ya=p(be);ta=i(Ya,"is"),Ya.forEach(t),aa=i(I," a recursive function."),I.forEach(t),Ve=u(e),ee=r(e,"P",{});var Fa=p(ee);sa=i(Fa,"This effort to preserve the intuition of developers coming from imperative languages extends way beyond fake looping constructs. It should say something that while I couldn’t find a syntax highlighter for koka to use on these code blocks, the javascript syntax highlighting looks pretty much fine. The language as a whole is designed to feel familiar to people used to C family syntax, but give superpowers that nothing in that family has."),Fa.forEach(t),Ye=u(e),te=r(e,"H2",{});var Ga=p(te);na=i(Ga,"No Compromises"),Ga.forEach(t),Fe=u(e),ae=r(e,"P",{});var Za=p(ae);oa=i(Za,"Usually, having discovered something beautiful and powerful that checks so many boxes, the cost is performance. Asking computers to do something so completely unrelated to their memory model is expensive, and so such languages usually come with bloated, slow runtimes that do the translation at the last possible minute. Sometimes, very clever compilers do things like tail call optimization to take common functional patterns and statically transform them into loops, but that can only go so far. While the nice tricks Koka is playing to give us mutable variables look like they do in-place updates, they still desugar to slow, piggy functions."),Za.forEach(t),Ge=u(e),se=r(e,"P",{});var Qa=p(se);ia=i(Qa,"Just kidding. They become stupid fast in-place updates with no need for a garbage collector."),Qa.forEach(t),Ze=u(e),g=r(e,"P",{});var oe=p(g);la=i(oe,"Koka does transform those mutable variables into a state effect to make sure to have all of the wonderful functional semantics that help us keep code composable, but it also uses the "),q=r(oe,"A",{href:!0,rel:!0});var Xa=p(q);ra=i(Xa,"Perceus"),Xa.forEach(t),pa=i(oe," compiler to transform that state effect into in-place updates wherever possible. Reuse analysis is even more powerful, taking clean functional expressions like list maps or tree traversals and transforming them into in-place mutations whenever possible, gracefully degrading back to shared memory persistent representations when not. The "),O=r(oe,"A",{href:!0,rel:!0});var es=p(O);ca=i(es,"Koka book"),es.forEach(t),ua=i(oe," explains this much better than I can, but it is worth glancing at the benchmarks they’ve done so far."),oe.forEach(t),Qe=u(e),C=r(e,"IMG",{src:!0,style:!0,alt:!0}),Xe=u(e),ne=r(e,"P",{});var ts=p(ne);ha=i(ts,"This unfinished research language can outperform C++. Benchmarks should always be taken with an ocean of salt, and these problems certainly weren’t chosen at random, but the firm foundation of Perceus gives me hope that these results are real and will be borne out in practice."),ts.forEach(t),et=u(e),M=r(e,"P",{});var it=p(M);fa=i(it,"It is early days for Koka. It isn’t ready for production, and new languages usually aren’t adopted, but there is "),ve=r(it,"EM",{});var as=p(ve);da=i(as,"so"),as.forEach(t),ma=i(it," much in Koka that is fundamentally better than existing languages that I would be heartbroken if these things didn’t catch on. Maybe it is a stepping stone, and something else will productionalize these ideas, but it is hard to imagine changing very much. Koka improves on the state of the art in so many places that it feels to me like making it productional is the path forward, rather than adopting these ideas into other languages."),it.forEach(t),this.h()},h(){_(A,"class","language-ts"),_(B,"class","language-ts"),_(S,"class","language-ts"),_(H,"class","language-ts"),_(q,"href","https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf"),_(q,"rel","nofollow"),_(O,"href","https://koka-lang.github.io/koka/doc/book.html#sec-fbip"),_(O,"rel","nofollow"),Is(C.src,ka="https://raw.githubusercontent.com/koka-lang/koka/master/doc/bench-amd3600-nov-2020.png")||_(C,"src",ka),xs(C,"max-width","800px"),_(C,"alt","benchmark comparing koka to other languages")},m(e,s){n(e,h,s),a(h,w),n(e,b,s),n(e,v,s),a(v,f),n(e,y,s),n(e,E,s),a(E,lt),n(e,ge,s),n(e,W,s),a(W,rt),n(e,_e,s),n(e,z,s),a(z,pt),n(e,Ee,s),n(e,D,s),a(D,ct),n(e,Ie,s),n(e,L,s),a(L,ut),n(e,xe,s),n(e,R,s),a(R,ht),n(e,Pe,s),n(e,N,s),a(N,ft),n(e,Te,s),n(e,U,s),a(U,dt),n(e,Ke,s),n(e,x,s),a(x,mt),a(x,ie),a(ie,yt),a(x,kt),n(e,je,s),n(e,J,s),a(J,wt),n(e,Ce,s),n(e,V,s),a(V,bt),n(e,Me,s),n(e,Y,s),a(Y,vt),n(e,Ae,s),n(e,A,s),A.innerHTML=is,n(e,Be,s),n(e,F,s),a(F,gt),n(e,Se,s),n(e,P,s),a(P,_t),a(P,le),a(le,Et),a(P,It),n(e,He,s),n(e,d,s),a(d,xt),a(d,re),a(re,Pt),a(d,Tt),a(d,pe),a(pe,Kt),a(d,jt),a(d,ce),a(ce,Ct),a(d,Mt),a(d,ue),a(ue,At),a(d,Bt),a(d,he),a(he,St),a(d,Ht),n(e,qe,s),n(e,B,s),B.innerHTML=ls,n(e,Oe,s),n(e,T,s),a(T,qt),a(T,fe),a(fe,Ot),a(T,$t),n(e,$e,s),n(e,G,s),a(G,Wt),n(e,We,s),n(e,K,s),a(K,zt),a(K,de),a(de,Dt),a(K,Lt),n(e,ze,s),n(e,S,s),S.innerHTML=rs,n(e,De,s),n(e,Z,s),a(Z,Rt),n(e,Le,s),n(e,Q,s),a(Q,Nt),n(e,Re,s),n(e,X,s),a(X,Ut),n(e,Ne,s),n(e,j,s),a(j,Jt),a(j,me),a(me,Vt),a(j,Yt),n(e,Ue,s),n(e,H,s),H.innerHTML=ps,n(e,Je,s),n(e,m,s),a(m,ye),a(ye,Ft),a(m,Gt),a(m,ke),a(ke,Zt),a(m,Qt),a(m,we),a(we,Xt),a(m,ea),a(m,be),a(be,ta),a(m,aa),n(e,Ve,s),n(e,ee,s),a(ee,sa),n(e,Ye,s),n(e,te,s),a(te,na),n(e,Fe,s),n(e,ae,s),a(ae,oa),n(e,Ge,s),n(e,se,s),a(se,ia),n(e,Ze,s),n(e,g,s),a(g,la),a(g,q),a(q,ra),a(g,pa),a(g,O),a(O,ca),a(g,ua),n(e,Qe,s),n(e,C,s),n(e,Xe,s),n(e,ne,s),a(ne,ha),n(e,et,s),n(e,M,s),a(M,fa),a(M,ve),a(ve,da),a(M,ma)},p:Ps,d(e){e&&t(h),e&&t(b),e&&t(v),e&&t(y),e&&t(E),e&&t(ge),e&&t(W),e&&t(_e),e&&t(z),e&&t(Ee),e&&t(D),e&&t(Ie),e&&t(L),e&&t(xe),e&&t(R),e&&t(Pe),e&&t(N),e&&t(Te),e&&t(U),e&&t(Ke),e&&t(x),e&&t(je),e&&t(J),e&&t(Ce),e&&t(V),e&&t(Me),e&&t(Y),e&&t(Ae),e&&t(A),e&&t(Be),e&&t(F),e&&t(Se),e&&t(P),e&&t(He),e&&t(d),e&&t(qe),e&&t(B),e&&t(Oe),e&&t(T),e&&t($e),e&&t(G),e&&t(We),e&&t(K),e&&t(ze),e&&t(S),e&&t(De),e&&t(Z),e&&t(Le),e&&t(Q),e&&t(Re),e&&t(X),e&&t(Ne),e&&t(j),e&&t(Ue),e&&t(H),e&&t(Je),e&&t(m),e&&t(Ve),e&&t(ee),e&&t(Ye),e&&t(te),e&&t(Fe),e&&t(ae),e&&t(Ge),e&&t(se),e&&t(Ze),e&&t(g),e&&t(Qe),e&&t(C),e&&t(Xe),e&&t(ne),e&&t(et),e&&t(M)}}}function js($){let h,w;const b=[$[0],os];let v={$$slots:{default:[Ks]},$$scope:{ctx:$}};for(let f=0;f<b.length;f+=1)v=ya(v,b[f]);return h=new Ts({props:v}),{c(){ks(h.$$.fragment)},l(f){ws(h.$$.fragment,f)},m(f,y){bs(h,f,y),w=!0},p(f,[y]){const E=y&1?vs(b,[y&1&&ss(f[0]),y&0&&ss(os)]):{};y&2&&(E.$$scope={dirty:y,ctx:f}),h.$set(E)},i(f){w||(gs(h.$$.fragment,f),w=!0)},o(f){_s(h.$$.fragment,f),w=!1},d(f){Es(h,f)}}}const os={title:"Koka vs the World",date:"2021-04-20T00:00:00.000Z",status:"published",blurb:"I love statically typed functional programming. Building up programs in statically typed functional style feels like a conversation with the compiler about what is possible. Python fanatics tell me over and over that you can't prototype that way. Unfortunately, heartbreakingly, sometimes they're right."};function Cs($,h,w){return $.$$set=b=>{w(0,h=ya(ya({},h),ns(b)))},h=ns(h),[h]}class Bs extends ds{constructor(h){super(),ms(this,h,Cs,js,ys,{})}}export{Bs as default,os as metadata};
