import{S as ds,i as ms,s as ys,D as ya,x as ks,y as ws,z as bs,A as vs,B as ss,r as gs,p as _s,C as Es,Q as ns,e as l,t as o,k as c,c as r,a as p,h as i,d as t,m as u,b as _,G as Is,f as xs,g as n,H as a,n as Ps}from"../../chunks/index-986541d7.js";import{B as Ts}from"../../chunks/blog-0a461edf.js";function Ks(q){let h,w,b,v,f,y,E,lt,ge,D,rt,_e,W,pt,Ee,z,ct,Ie,L,ut,xe,R,ht,Pe,N,ft,Te,U,dt,Ke,x,mt,ie,yt,kt,Ce,G,wt,je,J,bt,Me,V,vt,Ae,A,is=`<code class="language-ts">fun <span class="token function">first</span><span class="token punctuation">(</span>l<span class="token operator">:</span> list<span class="token operator">&lt;</span>a<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">match</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Cons</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> head
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</code>`,Be,Y,gt,Se,P,_t,le,Et,It,He,d,xt,re,Pt,Tt,pe,Kt,Ct,ce,jt,Mt,ue,At,Bt,he,St,Ht,Oe,B,ls=`<code class="language-ts">fun <span class="token function">dumb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> either<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> nirvana<span class="token operator">></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">with</span> control <span class="token function">raise</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token string">"Why did you think that would work?"</span><span class="token punctuation">.</span>Left<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
  <span class="token function">first</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">.</span>Right
<span class="token punctuation">&#125;</span></code>`,$e,T,Ot,fe,$t,qt,qe,Q,Dt,De,K,Wt,de,zt,Lt,We,S,rs=`<code class="language-ts">effect val postgres <span class="token operator">:</span> dbConnection

fun <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> postgres <span class="token punctuation">&#123;</span>
  <span class="token operator">...</span><span class="token punctuation">.</span> <span class="token comment">// arbitrary use of postgres at any depth as a value internally</span>
<span class="token punctuation">&#125;</span>

fun <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">with</span> val postgres <span class="token operator">=</span> realConnection
  <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

fun <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">with</span> val postgres <span class="token operator">=</span> testMock
  <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,ze,Z,Rt,Le,F,Nt,Re,X,Ut,Ne,C,Gt,me,Jt,Vt,Ue,H,ps=`<code class="language-ts">fun <span class="token keyword">while</span><span class="token punctuation">(</span> predicate <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&lt;</span>div<span class="token operator">|</span>e<span class="token operator">></span> bool<span class="token punctuation">,</span> action <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&lt;</span>div<span class="token operator">|</span>e<span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">&lt;</span>div<span class="token operator">|</span>e<span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">predicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> action<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">while</span> <span class="token punctuation">&#123;</span>condition <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm secretly functional!"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Ge,m,ye,Yt,Qt,ke,Zt,Ft,we,Xt,ea,be,ta,aa,Je,ee,sa,Ve,te,na,Ye,ae,oa,Qe,se,ia,Ze,g,la,O,ra,pa,$,ca,ua,Fe,j,ka,Xe,ne,ha,et,M,fa,ve,da,ma;return{c(){h=l("p"),w=o("I love statically typed functional programming. Building up programs in statically typed functional style feels like a conversation with the compiler about what is possible."),b=c(),v=l("p"),f=o("Python fanatics tell me over and over that you can\u2019t prototype that way. Unfortunately, heartbreakingly, sometimes they\u2019re right."),y=c(),E=l("h2"),lt=o("Prototyping"),ge=c(),D=l("p"),rt=o("Sometimes it is much easier to get to a useful product if you accept that you don\u2019t understand how it works in an edge case. I wanted a compiler that could say \u201CI can work with this, but you should clean it up later\u201D. I didn\u2019t found one."),_e=c(),W=l("h2"),pt=o("Postgres"),Ee=c(),z=l("p"),ct=o("Sometimes you need to interact with complicated, outside resources like databases, and purity feels like a fools errand. I wanted a compiler that would let me compose with impunity, but still remember that somewhere in the program I need to give it a database. I didn\u2019t found one."),Ie=c(),L=l("h2"),ut=o("Performance"),xe=c(),R=l("p"),ht=o("This has become somewhat less important now that the frame of reference for a lot of people is javascript and python rather than C, but functional languages can perform quite badly and use a lot of memory because they want everything to be immutable. I wanted a compiler that could take nice functional code and rewrite it based on the context to be performant and imperative, but somewhere I didn\u2019t have to see it. I didn\u2019t find one."),Pe=c(),N=l("h2"),ft=o("Preferences"),Te=c(),U=l("p"),dt=o("Sometimes you have someone on your team who has the same love of mutable state that I have of static types and function composition. I wanted a compiler that could let them have their fun, but create clean, tight barriers around mutations so that I could see from the type whether or not I had to deal with that nonsense. I didn\u2019t find one."),Ke=c(),x=l("p"),mt=o("I did not expect these problems to have the same solution. I thought these were unrelated flaws of the languages I loved, and that the only solution was to work in multiparadigm languages and be "),ie=l("em"),yt=o("very very careful"),kt=o(" because I could never quite trust the types. I figured that if the problem were solvable, someone would have solved it in the last 47 years of research."),Ce=c(),G=l("p"),wt=o("Then a friend showed me Koka."),je=c(),J=l("h2"),bt=o("Effect Types for Prototyping"),Me=c(),V=l("p"),vt=o("The first thing I saw reading about Koka was that it had exceptions, and I almost gave up there. Exceptions are the biggest footgun that I have to worry about on a daily basis. Seeing them in a nice pure language I felt cheated and lied to. But in Koka, something is different when you throw an exception; it is captured in the type."),Ae=c(),A=l("pre"),Be=c(),Y=l("p"),gt=o("This code takes a list and gives back its first element. There are cleaner ways to do this, but for illustration I wanted to write it out fully."),Se=c(),P=l("p"),_t=o("In most functional languages, this wouldn\u2019t compile. \u201CThat pattern matching isn\u2019t complete\u201D, they would say. \u201CWhat if you got an empty list?\u201D they would say. So programmers, not able to explain to the compiler that they are "),le=l("em"),Et=o("absolutely certain"),It=o(" that won\u2019t happen, switch away from such languages to something a little more practical (typescript) and just let the code throw."),He=c(),d=l("p"),xt=o("Everybody lives happily ever after, until this prototyping code is embedded in the core of a Very Important Model being used in production, and it actually does get an empty list because the code has been rewritten half a dozen times since the programmer was "),re=l("em"),Pt=o("absolutely certain"),Tt=o(" that couldn\u2019t happen. But in Koka, unlike in typescript, the return type of this function "),pe=l("em"),Kt=o("remembers"),Ct=o(" that there can be an exception. The return type here is inferred as "),ce=l("code"),jt=o("exn a"),Mt=o(" rather than just "),ue=l("code"),At=o("a"),Bt=o(". Any function calling this also gets that "),he=l("code"),St=o("exn"),Ht=o(" effect added to its type, until the programmer goes back and deals with that effect and removes it everywhere or catches it with an effect handler."),Oe=c(),B=l("pre"),$e=c(),T=l("p"),Ot=o("Now anything calling "),fe=l("code"),$t=o("dumb"),qt=o(" can be certain that the exception was handled, and doesn\u2019t need to worry about it anymore. This gives us a clean way to iteratively integrate prototype code into a production codebase, by looking at the type and controlling for unknowns or rewriting to rule them out."),qe=c(),Q=l("h2"),Dt=o("Effect Types for Postgres"),De=c(),K=l("p"),Wt=o("I was sold. You could write exceptional code and prototype away, and clean up after yourself later. I figured that was it, that was the clever trick for this language, but effect types are "),de=l("em"),zt=o("so much better than that"),Lt=o(". Effects aren\u2019t limited to those defined in the language, you can make up your own in user land. This means that I can write an effect like this;"),We=c(),S=l("pre"),ze=c(),Z=l("p"),Rt=o("This is dependency injection, but without any of the horrible nonsense of passing dependencies down all the way through the application or currying everywhere to create versions of services with the dependency in the closure. Any function can say \u201CI need access to the database\u201D by declaring the effect, and Koka handles the rest. This magic is actually the same semantic that Koka used to define exceptions, restricted to the case where the result of the effect was always a single value. And even better, while real database connections probably have all sorts of gross side effects, this injection can be polymorphic over the effect to let us be sure that our code in the test case can stay pure and deterministic."),Le=c(),F=l("h2"),Nt=o("Effect Types (and Trailing Lambdas) for Preferences"),Re=c(),X=l("p"),Ut=o("Alright, that\u2019s it then. Effect types solve the prototyping problem, and give a beautiful new pattern for dependency injection. What more can we ask for?"),Ne=c(),C=l("p"),Gt=o("One of the biggest barriers that functional languages face is just about what people already know. Programmers want to write loops because they are used to loops, and it doesn\u2019t matter if there is an equivalent functional program; if they aren\u2019t used to it it will be harder to debug and not worth their time. But Koka "),me=l("em"),Jt=o("has"),Vt=o(" while loops. And they are functions, defined in user land."),Ue=c(),H=l("pre"),Ge=c(),m=l("p"),ye=l("code"),Yt=o("while"),Qt=o(" here is just a function, with Koka providing a bunch of syntactic sugar to make the way you call it more familiar to those comfortable in imperative languages. The fact that it\u2019s still a function means that all of the composable semantics that we get out of effect types and function composition still apply to code using loops of this form, even though the code looks dirty and imperative. Even the infinite loop here is captured by the type system. Koka infers that anything using this function has the "),ke=l("code"),Zt=o("div"),Ft=o(" effect, meaning it might run forever without producing a value. This is the same effect it would infer for a recursive function, because "),we=l("code"),Xt=o("while"),ea=c(),be=l("em"),ta=o("is"),aa=o(" a recursive function."),Je=c(),ee=l("p"),sa=o("This effort to preserve the intuition of developers coming from imperative languages extends way beyond fake looping constructs. It should say something that while I couldn\u2019t find a syntax highlighter for koka to use on these code blocks, the javascript syntax highlighting looks pretty much fine. The language as a whole is designed to feel familiar to people used to C family syntax, but give superpowers that nothing in that family has."),Ve=c(),te=l("h2"),na=o("No Compromises"),Ye=c(),ae=l("p"),oa=o("Usually, having discovered something beautiful and powerful that checks so many boxes, the cost is performance. Asking computers to do something so completely unrelated to their memory model is expensive, and so such languages usually come with bloated, slow runtimes that do the translation at the last possible minute. Sometimes, very clever compilers do things like tail call optimization to take common functional patterns and statically transform them into loops, but that can only go so far. While the nice tricks Koka is playing to give us mutable variables look like they do in-place updates, they still desugar to slow, piggy functions."),Qe=c(),se=l("p"),ia=o("Just kidding. They become stupid fast in-place updates with no need for a garbage collector."),Ze=c(),g=l("p"),la=o("Koka does transform those mutable variables into a state effect to make sure to have all of the wonderful functional semantics that help us keep code composable, but it also uses the "),O=l("a"),ra=o("Perceus"),pa=o(" compiler to transform that state effect into in-place updates wherever possible. Reuse analysis is even more powerful, taking clean functional expressions like list maps or tree traversals and transforming them into in-place mutations whenever possible, gracefully degrading back to shared memory persistent representations when not. The "),$=l("a"),ca=o("Koka book"),ua=o(" explains this much better than I can, but it is worth glancing at the benchmarks they\u2019ve done so far."),Fe=c(),j=l("img"),Xe=c(),ne=l("p"),ha=o("This unfinished research language can outperform C++. Benchmarks should always be taken with an ocean of salt, and these problems certainly weren\u2019t chosen at random, but the firm foundation of Perceus gives me hope that these results are real and will be borne out in practice."),et=c(),M=l("p"),fa=o("It is early days for Koka. It isn\u2019t ready for production, and new languages usually aren\u2019t adopted, but there is "),ve=l("em"),da=o("so"),ma=o(" much in Koka that is fundamentally better than existing languages that I would be heartbroken if these things didn\u2019t catch on. Maybe it is a stepping stone, and something else will productionalize these ideas, but it is hard to imagine changing very much. Koka improves on the state of the art in so many places that it feels to me like making it productional is the path forward, rather than adopting these ideas into other languages."),this.h()},l(e){h=r(e,"P",{});var s=p(h);w=i(s,"I love statically typed functional programming. Building up programs in statically typed functional style feels like a conversation with the compiler about what is possible."),s.forEach(t),b=u(e),v=r(e,"P",{});var wa=p(v);f=i(wa,"Python fanatics tell me over and over that you can\u2019t prototype that way. Unfortunately, heartbreakingly, sometimes they\u2019re right."),wa.forEach(t),y=u(e),E=r(e,"H2",{});var ba=p(E);lt=i(ba,"Prototyping"),ba.forEach(t),ge=u(e),D=r(e,"P",{});var va=p(D);rt=i(va,"Sometimes it is much easier to get to a useful product if you accept that you don\u2019t understand how it works in an edge case. I wanted a compiler that could say \u201CI can work with this, but you should clean it up later\u201D. I didn\u2019t found one."),va.forEach(t),_e=u(e),W=r(e,"H2",{});var ga=p(W);pt=i(ga,"Postgres"),ga.forEach(t),Ee=u(e),z=r(e,"P",{});var _a=p(z);ct=i(_a,"Sometimes you need to interact with complicated, outside resources like databases, and purity feels like a fools errand. I wanted a compiler that would let me compose with impunity, but still remember that somewhere in the program I need to give it a database. I didn\u2019t found one."),_a.forEach(t),Ie=u(e),L=r(e,"H2",{});var Ea=p(L);ut=i(Ea,"Performance"),Ea.forEach(t),xe=u(e),R=r(e,"P",{});var Ia=p(R);ht=i(Ia,"This has become somewhat less important now that the frame of reference for a lot of people is javascript and python rather than C, but functional languages can perform quite badly and use a lot of memory because they want everything to be immutable. I wanted a compiler that could take nice functional code and rewrite it based on the context to be performant and imperative, but somewhere I didn\u2019t have to see it. I didn\u2019t find one."),Ia.forEach(t),Pe=u(e),N=r(e,"H2",{});var xa=p(N);ft=i(xa,"Preferences"),xa.forEach(t),Te=u(e),U=r(e,"P",{});var Pa=p(U);dt=i(Pa,"Sometimes you have someone on your team who has the same love of mutable state that I have of static types and function composition. I wanted a compiler that could let them have their fun, but create clean, tight barriers around mutations so that I could see from the type whether or not I had to deal with that nonsense. I didn\u2019t find one."),Pa.forEach(t),Ke=u(e),x=r(e,"P",{});var tt=p(x);mt=i(tt,"I did not expect these problems to have the same solution. I thought these were unrelated flaws of the languages I loved, and that the only solution was to work in multiparadigm languages and be "),ie=r(tt,"EM",{});var Ta=p(ie);yt=i(Ta,"very very careful"),Ta.forEach(t),kt=i(tt," because I could never quite trust the types. I figured that if the problem were solvable, someone would have solved it in the last 47 years of research."),tt.forEach(t),Ce=u(e),G=r(e,"P",{});var Ka=p(G);wt=i(Ka,"Then a friend showed me Koka."),Ka.forEach(t),je=u(e),J=r(e,"H2",{});var Ca=p(J);bt=i(Ca,"Effect Types for Prototyping"),Ca.forEach(t),Me=u(e),V=r(e,"P",{});var ja=p(V);vt=i(ja,"The first thing I saw reading about Koka was that it had exceptions, and I almost gave up there. Exceptions are the biggest footgun that I have to worry about on a daily basis. Seeing them in a nice pure language I felt cheated and lied to. But in Koka, something is different when you throw an exception; it is captured in the type."),ja.forEach(t),Ae=u(e),A=r(e,"PRE",{class:!0});var cs=p(A);cs.forEach(t),Be=u(e),Y=r(e,"P",{});var Ma=p(Y);gt=i(Ma,"This code takes a list and gives back its first element. There are cleaner ways to do this, but for illustration I wanted to write it out fully."),Ma.forEach(t),Se=u(e),P=r(e,"P",{});var at=p(P);_t=i(at,"In most functional languages, this wouldn\u2019t compile. \u201CThat pattern matching isn\u2019t complete\u201D, they would say. \u201CWhat if you got an empty list?\u201D they would say. So programmers, not able to explain to the compiler that they are "),le=r(at,"EM",{});var Aa=p(le);Et=i(Aa,"absolutely certain"),Aa.forEach(t),It=i(at," that won\u2019t happen, switch away from such languages to something a little more practical (typescript) and just let the code throw."),at.forEach(t),He=u(e),d=r(e,"P",{});var k=p(d);xt=i(k,"Everybody lives happily ever after, until this prototyping code is embedded in the core of a Very Important Model being used in production, and it actually does get an empty list because the code has been rewritten half a dozen times since the programmer was "),re=r(k,"EM",{});var Ba=p(re);Pt=i(Ba,"absolutely certain"),Ba.forEach(t),Tt=i(k," that couldn\u2019t happen. But in Koka, unlike in typescript, the return type of this function "),pe=r(k,"EM",{});var Sa=p(pe);Kt=i(Sa,"remembers"),Sa.forEach(t),Ct=i(k," that there can be an exception. The return type here is inferred as "),ce=r(k,"CODE",{});var Ha=p(ce);jt=i(Ha,"exn a"),Ha.forEach(t),Mt=i(k," rather than just "),ue=r(k,"CODE",{});var Oa=p(ue);At=i(Oa,"a"),Oa.forEach(t),Bt=i(k,". Any function calling this also gets that "),he=r(k,"CODE",{});var $a=p(he);St=i($a,"exn"),$a.forEach(t),Ht=i(k," effect added to its type, until the programmer goes back and deals with that effect and removes it everywhere or catches it with an effect handler."),k.forEach(t),Oe=u(e),B=r(e,"PRE",{class:!0});var us=p(B);us.forEach(t),$e=u(e),T=r(e,"P",{});var st=p(T);Ot=i(st,"Now anything calling "),fe=r(st,"CODE",{});var qa=p(fe);$t=i(qa,"dumb"),qa.forEach(t),qt=i(st," can be certain that the exception was handled, and doesn\u2019t need to worry about it anymore. This gives us a clean way to iteratively integrate prototype code into a production codebase, by looking at the type and controlling for unknowns or rewriting to rule them out."),st.forEach(t),qe=u(e),Q=r(e,"H2",{});var Da=p(Q);Dt=i(Da,"Effect Types for Postgres"),Da.forEach(t),De=u(e),K=r(e,"P",{});var nt=p(K);Wt=i(nt,"I was sold. You could write exceptional code and prototype away, and clean up after yourself later. I figured that was it, that was the clever trick for this language, but effect types are "),de=r(nt,"EM",{});var Wa=p(de);zt=i(Wa,"so much better than that"),Wa.forEach(t),Lt=i(nt,". Effects aren\u2019t limited to those defined in the language, you can make up your own in user land. This means that I can write an effect like this;"),nt.forEach(t),We=u(e),S=r(e,"PRE",{class:!0});var hs=p(S);hs.forEach(t),ze=u(e),Z=r(e,"P",{});var za=p(Z);Rt=i(za,"This is dependency injection, but without any of the horrible nonsense of passing dependencies down all the way through the application or currying everywhere to create versions of services with the dependency in the closure. Any function can say \u201CI need access to the database\u201D by declaring the effect, and Koka handles the rest. This magic is actually the same semantic that Koka used to define exceptions, restricted to the case where the result of the effect was always a single value. And even better, while real database connections probably have all sorts of gross side effects, this injection can be polymorphic over the effect to let us be sure that our code in the test case can stay pure and deterministic."),za.forEach(t),Le=u(e),F=r(e,"H2",{});var La=p(F);Nt=i(La,"Effect Types (and Trailing Lambdas) for Preferences"),La.forEach(t),Re=u(e),X=r(e,"P",{});var Ra=p(X);Ut=i(Ra,"Alright, that\u2019s it then. Effect types solve the prototyping problem, and give a beautiful new pattern for dependency injection. What more can we ask for?"),Ra.forEach(t),Ne=u(e),C=r(e,"P",{});var ot=p(C);Gt=i(ot,"One of the biggest barriers that functional languages face is just about what people already know. Programmers want to write loops because they are used to loops, and it doesn\u2019t matter if there is an equivalent functional program; if they aren\u2019t used to it it will be harder to debug and not worth their time. But Koka "),me=r(ot,"EM",{});var Na=p(me);Jt=i(Na,"has"),Na.forEach(t),Vt=i(ot," while loops. And they are functions, defined in user land."),ot.forEach(t),Ue=u(e),H=r(e,"PRE",{class:!0});var fs=p(H);fs.forEach(t),Ge=u(e),m=r(e,"P",{});var I=p(m);ye=r(I,"CODE",{});var Ua=p(ye);Yt=i(Ua,"while"),Ua.forEach(t),Qt=i(I," here is just a function, with Koka providing a bunch of syntactic sugar to make the way you call it more familiar to those comfortable in imperative languages. The fact that it\u2019s still a function means that all of the composable semantics that we get out of effect types and function composition still apply to code using loops of this form, even though the code looks dirty and imperative. Even the infinite loop here is captured by the type system. Koka infers that anything using this function has the "),ke=r(I,"CODE",{});var Ga=p(ke);Zt=i(Ga,"div"),Ga.forEach(t),Ft=i(I," effect, meaning it might run forever without producing a value. This is the same effect it would infer for a recursive function, because "),we=r(I,"CODE",{});var Ja=p(we);Xt=i(Ja,"while"),Ja.forEach(t),ea=u(I),be=r(I,"EM",{});var Va=p(be);ta=i(Va,"is"),Va.forEach(t),aa=i(I," a recursive function."),I.forEach(t),Je=u(e),ee=r(e,"P",{});var Ya=p(ee);sa=i(Ya,"This effort to preserve the intuition of developers coming from imperative languages extends way beyond fake looping constructs. It should say something that while I couldn\u2019t find a syntax highlighter for koka to use on these code blocks, the javascript syntax highlighting looks pretty much fine. The language as a whole is designed to feel familiar to people used to C family syntax, but give superpowers that nothing in that family has."),Ya.forEach(t),Ve=u(e),te=r(e,"H2",{});var Qa=p(te);na=i(Qa,"No Compromises"),Qa.forEach(t),Ye=u(e),ae=r(e,"P",{});var Za=p(ae);oa=i(Za,"Usually, having discovered something beautiful and powerful that checks so many boxes, the cost is performance. Asking computers to do something so completely unrelated to their memory model is expensive, and so such languages usually come with bloated, slow runtimes that do the translation at the last possible minute. Sometimes, very clever compilers do things like tail call optimization to take common functional patterns and statically transform them into loops, but that can only go so far. While the nice tricks Koka is playing to give us mutable variables look like they do in-place updates, they still desugar to slow, piggy functions."),Za.forEach(t),Qe=u(e),se=r(e,"P",{});var Fa=p(se);ia=i(Fa,"Just kidding. They become stupid fast in-place updates with no need for a garbage collector."),Fa.forEach(t),Ze=u(e),g=r(e,"P",{});var oe=p(g);la=i(oe,"Koka does transform those mutable variables into a state effect to make sure to have all of the wonderful functional semantics that help us keep code composable, but it also uses the "),O=r(oe,"A",{href:!0,rel:!0});var Xa=p(O);ra=i(Xa,"Perceus"),Xa.forEach(t),pa=i(oe," compiler to transform that state effect into in-place updates wherever possible. Reuse analysis is even more powerful, taking clean functional expressions like list maps or tree traversals and transforming them into in-place mutations whenever possible, gracefully degrading back to shared memory persistent representations when not. The "),$=r(oe,"A",{href:!0,rel:!0});var es=p($);ca=i(es,"Koka book"),es.forEach(t),ua=i(oe," explains this much better than I can, but it is worth glancing at the benchmarks they\u2019ve done so far."),oe.forEach(t),Fe=u(e),j=r(e,"IMG",{src:!0,style:!0,alt:!0}),Xe=u(e),ne=r(e,"P",{});var ts=p(ne);ha=i(ts,"This unfinished research language can outperform C++. Benchmarks should always be taken with an ocean of salt, and these problems certainly weren\u2019t chosen at random, but the firm foundation of Perceus gives me hope that these results are real and will be borne out in practice."),ts.forEach(t),et=u(e),M=r(e,"P",{});var it=p(M);fa=i(it,"It is early days for Koka. It isn\u2019t ready for production, and new languages usually aren\u2019t adopted, but there is "),ve=r(it,"EM",{});var as=p(ve);da=i(as,"so"),as.forEach(t),ma=i(it," much in Koka that is fundamentally better than existing languages that I would be heartbroken if these things didn\u2019t catch on. Maybe it is a stepping stone, and something else will productionalize these ideas, but it is hard to imagine changing very much. Koka improves on the state of the art in so many places that it feels to me like making it productional is the path forward, rather than adopting these ideas into other languages."),it.forEach(t),this.h()},h(){_(A,"class","language-ts"),_(B,"class","language-ts"),_(S,"class","language-ts"),_(H,"class","language-ts"),_(O,"href","https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf"),_(O,"rel","nofollow"),_($,"href","https://koka-lang.github.io/koka/doc/book.html#sec-fbip"),_($,"rel","nofollow"),Is(j.src,ka="https://raw.githubusercontent.com/koka-lang/koka/master/doc/bench-amd3600-nov-2020.png")||_(j,"src",ka),xs(j,"max-width","800px"),_(j,"alt","benchmark comparing koka to other languages")},m(e,s){n(e,h,s),a(h,w),n(e,b,s),n(e,v,s),a(v,f),n(e,y,s),n(e,E,s),a(E,lt),n(e,ge,s),n(e,D,s),a(D,rt),n(e,_e,s),n(e,W,s),a(W,pt),n(e,Ee,s),n(e,z,s),a(z,ct),n(e,Ie,s),n(e,L,s),a(L,ut),n(e,xe,s),n(e,R,s),a(R,ht),n(e,Pe,s),n(e,N,s),a(N,ft),n(e,Te,s),n(e,U,s),a(U,dt),n(e,Ke,s),n(e,x,s),a(x,mt),a(x,ie),a(ie,yt),a(x,kt),n(e,Ce,s),n(e,G,s),a(G,wt),n(e,je,s),n(e,J,s),a(J,bt),n(e,Me,s),n(e,V,s),a(V,vt),n(e,Ae,s),n(e,A,s),A.innerHTML=is,n(e,Be,s),n(e,Y,s),a(Y,gt),n(e,Se,s),n(e,P,s),a(P,_t),a(P,le),a(le,Et),a(P,It),n(e,He,s),n(e,d,s),a(d,xt),a(d,re),a(re,Pt),a(d,Tt),a(d,pe),a(pe,Kt),a(d,Ct),a(d,ce),a(ce,jt),a(d,Mt),a(d,ue),a(ue,At),a(d,Bt),a(d,he),a(he,St),a(d,Ht),n(e,Oe,s),n(e,B,s),B.innerHTML=ls,n(e,$e,s),n(e,T,s),a(T,Ot),a(T,fe),a(fe,$t),a(T,qt),n(e,qe,s),n(e,Q,s),a(Q,Dt),n(e,De,s),n(e,K,s),a(K,Wt),a(K,de),a(de,zt),a(K,Lt),n(e,We,s),n(e,S,s),S.innerHTML=rs,n(e,ze,s),n(e,Z,s),a(Z,Rt),n(e,Le,s),n(e,F,s),a(F,Nt),n(e,Re,s),n(e,X,s),a(X,Ut),n(e,Ne,s),n(e,C,s),a(C,Gt),a(C,me),a(me,Jt),a(C,Vt),n(e,Ue,s),n(e,H,s),H.innerHTML=ps,n(e,Ge,s),n(e,m,s),a(m,ye),a(ye,Yt),a(m,Qt),a(m,ke),a(ke,Zt),a(m,Ft),a(m,we),a(we,Xt),a(m,ea),a(m,be),a(be,ta),a(m,aa),n(e,Je,s),n(e,ee,s),a(ee,sa),n(e,Ve,s),n(e,te,s),a(te,na),n(e,Ye,s),n(e,ae,s),a(ae,oa),n(e,Qe,s),n(e,se,s),a(se,ia),n(e,Ze,s),n(e,g,s),a(g,la),a(g,O),a(O,ra),a(g,pa),a(g,$),a($,ca),a(g,ua),n(e,Fe,s),n(e,j,s),n(e,Xe,s),n(e,ne,s),a(ne,ha),n(e,et,s),n(e,M,s),a(M,fa),a(M,ve),a(ve,da),a(M,ma)},p:Ps,d(e){e&&t(h),e&&t(b),e&&t(v),e&&t(y),e&&t(E),e&&t(ge),e&&t(D),e&&t(_e),e&&t(W),e&&t(Ee),e&&t(z),e&&t(Ie),e&&t(L),e&&t(xe),e&&t(R),e&&t(Pe),e&&t(N),e&&t(Te),e&&t(U),e&&t(Ke),e&&t(x),e&&t(Ce),e&&t(G),e&&t(je),e&&t(J),e&&t(Me),e&&t(V),e&&t(Ae),e&&t(A),e&&t(Be),e&&t(Y),e&&t(Se),e&&t(P),e&&t(He),e&&t(d),e&&t(Oe),e&&t(B),e&&t($e),e&&t(T),e&&t(qe),e&&t(Q),e&&t(De),e&&t(K),e&&t(We),e&&t(S),e&&t(ze),e&&t(Z),e&&t(Le),e&&t(F),e&&t(Re),e&&t(X),e&&t(Ne),e&&t(C),e&&t(Ue),e&&t(H),e&&t(Ge),e&&t(m),e&&t(Je),e&&t(ee),e&&t(Ve),e&&t(te),e&&t(Ye),e&&t(ae),e&&t(Qe),e&&t(se),e&&t(Ze),e&&t(g),e&&t(Fe),e&&t(j),e&&t(Xe),e&&t(ne),e&&t(et),e&&t(M)}}}function Cs(q){let h,w;const b=[q[0],os];let v={$$slots:{default:[Ks]},$$scope:{ctx:q}};for(let f=0;f<b.length;f+=1)v=ya(v,b[f]);return h=new Ts({props:v}),{c(){ks(h.$$.fragment)},l(f){ws(h.$$.fragment,f)},m(f,y){bs(h,f,y),w=!0},p(f,[y]){const E=y&1?vs(b,[y&1&&ss(f[0]),y&0&&ss(os)]):{};y&2&&(E.$$scope={dirty:y,ctx:f}),h.$set(E)},i(f){w||(gs(h.$$.fragment,f),w=!0)},o(f){_s(h.$$.fragment,f),w=!1},d(f){Es(h,f)}}}const os={title:"Koka vs the World",date:"2021-04-20T00:00:00.000Z",status:"published",blurb:"I love statically typed functional programming. Building up programs in statically typed functional style feels like a conversation with the compiler about what is possible. Python fanatics tell me over and over that you can't prototype that way. Unfortunately, heartbreakingly, sometimes they're right."};function js(q,h,w){return q.$$set=b=>{w(0,h=ya(ya({},h),ns(b)))},h=ns(h),[h]}class Bs extends ds{constructor(h){super(),ms(this,h,js,Cs,ys,{})}}export{Bs as default,os as metadata};
