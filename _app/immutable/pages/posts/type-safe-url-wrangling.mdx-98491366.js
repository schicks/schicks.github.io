import{S as Bd,i as Dd,s as Ad,D as ri,x as Pd,y as Kd,z as Ld,A as Sd,B as Ph,r as Rd,p as jd,C as Vd,O as Kh,e as o,t as a,k as i,c as p,a as l,h as n,d as s,m as u,b as y,g as c,H as t,n as Id}from"../../chunks/index-911407ad.js";import{B as Md}from"../../chunks/blog-9875105f.js";function Hd(Je){let k,W,I,me,m,U,M,lo,we,ro,co,fa,F,io,bt,uo,ho,Et,yo,ko,ma,Z,gt,fo,mo,_t,wo,wa,Q,vo,Ct,bo,Eo,ve,go,_o,va,Ye,Co,ba,x,Oo,Ot,To,Uo,Tt,xo,Bo,Ut,Do,Ao,Ea,ze,Po,ga,Ze,Ko,_a,be,Sh=`<code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Value<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span>_brand<span class="token operator">:</span> Brand<span class="token punctuation">&#125;</span>
<span class="token operator">|</span> <span class="token keyword">null</span>
<span class="token operator">|</span> <span class="token keyword">undefined</span>

<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">StateForKeys<span class="token operator">&lt;</span>UrlKeys <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span> Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>key <span class="token keyword">in</span> UrlKeys<span class="token punctuation">]</span><span class="token operator">:</span> Value<span class="token operator">&lt;</span>Brand<span class="token operator">></span>
<span class="token punctuation">&#125;</span>


<span class="token comment">// give me all of the keys of an object type O</span>
<span class="token comment">// which have values that extend some type V</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">KeysByValue<span class="token operator">&lt;</span><span class="token constant">O</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">O</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">O</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">V</span></span> <span class="token operator">?</span> key <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">O</span><span class="token punctuation">]</span>

<span class="token comment">// give me the object formed of such keys</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PickByValue<span class="token operator">&lt;</span><span class="token constant">O</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">O</span><span class="token punctuation">,</span> KeysByValue<span class="token operator">&lt;</span><span class="token constant">O</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">>></span></code>`,Ca,N,Lo,xt,So,Ro,Oa,Ee,Rh=`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> StateForKeys <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/useUrlParams/types'</span>

<span class="token comment">// Any string unique to each component</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Brand</span> <span class="token operator">=</span> <span class="token string">'componentBrand'</span>

<span class="token keyword">type</span> <span class="token class-name">Keys</span> <span class="token operator">=</span> <span class="token string">'union'</span> <span class="token operator">|</span> <span class="token string">'of'</span> <span class="token operator">|</span> <span class="token string">'url'</span> <span class="token operator">|</span> <span class="token string">'keys'</span>

<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> StateForKeys<span class="token operator">&lt;</span>Keys<span class="token punctuation">,</span> Brand<span class="token operator">></span></code>`,Ta,X,jo,Bt,Vo,Io,Ua,ge,jh=`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>UrlState <span class="token keyword">as</span> AUrlState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentA/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>UrlState <span class="token keyword">as</span> BUrlState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentB/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>UrlState <span class="token keyword">as</span> CUrlState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentC/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>PickByValue<span class="token punctuation">,</span> KeysByValue<span class="token punctuation">,</span> Value<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/useUrlParams/types'</span>

<span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> AUrlState <span class="token operator">&amp;</span> BUrlState <span class="token operator">&amp;</span> CUrlState



<span class="token comment">// Type of the state accessible by a particular brand</span>
<span class="token keyword">type</span> <span class="token class-name">StateFor<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> PickByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> Value<span class="token operator">&lt;</span>Brand<span class="token operator">>></span>

<span class="token comment">// only keys which are assigned to multiple brands will extend null | undefined.</span>
<span class="token comment">// Therefore this function has return type never</span>
<span class="token comment">// as long as no key is assigned to multiple brands.</span>
<span class="token keyword">const</span> _brands_dont_overlap <span class="token operator">=</span> <span class="token punctuation">(</span>
  keys_assigned_to_multiple_brands<span class="token operator">:</span> KeysByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=></span> keys_assigned_to_multiple_brands

<span class="token keyword">const</span> _url_state_conforms <span class="token operator">=</span> <span class="token punctuation">(</span>
  state<span class="token operator">:</span> UrlState
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> Value<span class="token operator">&lt;</span>Brands<span class="token operator">></span><span class="token punctuation">&#125;</span>  <span class="token operator">=></span> state

<span class="token keyword">export</span> <span class="token keyword">const</span> useUrlParams <span class="token operator">=</span> <span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  StateFor<span class="token operator">&lt;</span>Brand<span class="token operator">></span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span>entries<span class="token operator">:</span> Partial<span class="token operator">&lt;</span>StateFor<span class="token operator">&lt;</span>Brand<span class="token operator">>></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">]</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token operator">...</span>
<span class="token punctuation">&#125;</span></code>`,xa,B,Mo,Dt,Ho,Wo,At,Fo,Qo,Pt,qo,Go,Ba,_e,Vh=`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>Brand<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentA/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>useUrlParams<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> 'components<span class="token operator">/</span>useUrlParams

<span class="token keyword">const</span> <span class="token function-variable function">ComponentA</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>urlState<span class="token punctuation">,</span> push<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useUrlParams</span><span class="token generic class-name"><span class="token operator">&lt;</span>Brand<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>
</code>`,Da,Ne,Jo,Aa,Xe,Yo,Pa,$e,zo,Ka,et,Zo,La,tt,No,Sa,Ce,Ih=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Keys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token string">'c'</span> <span class="token comment">// keys of interest</span>

<span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>Key <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#125;</span></code>`,Ra,D,Xo,Kt,$o,ep,Lt,tp,sp,St,ap,np,ja,Oe,Mh=`<code class="language-typescript"><span class="token comment">// return type will be inferred as string | null | undefined</span>
<span class="token keyword">const</span> <span class="token function-variable function">getA</span> <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> UrlState<span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>a

<span class="token comment">// this will cause a type error since nonsense can't satisfy the &#96;Keys&#96; type</span>
<span class="token keyword">const</span> getNonsense <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> UrlState<span class="token punctuation">)</span> state<span class="token punctuation">.</span>nonsense</code>`,Va,st,op,Ia,Te,Hh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Keys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token string">'c'</span>

<span class="token comment">// resolves to &#123;a: 'a', b: 'b', c: 'c'&#125;</span>
<span class="token keyword">type</span> <span class="token class-name">Identity</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>Key <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> Key <span class="token punctuation">&#125;</span></code>`,Ma,at,pp,Ha,nt,lp,Wa,Ue,Wh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IdMapping</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  a<span class="token operator">:</span> <span class="token string">'id_a'</span>
  b<span class="token operator">:</span> <span class="token string">'id_b'</span>
  c<span class="token operator">:</span> <span class="token string">'id_c'</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 'id_a'</span>
<span class="token keyword">type</span> <span class="token class-name">IdA</span> <span class="token operator">=</span> IdMapping<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span>

<span class="token comment">// 'id_a' | 'id_b' | 'id_c'</span>
<span class="token keyword">type</span> <span class="token class-name">Ids</span> <span class="token operator">=</span> IdMapping<span class="token punctuation">[</span><span class="token keyword">keyof</span> IdMapping<span class="token punctuation">]</span></code>`,Fa,ot,rp,Qa,pt,cp,qa,lt,ip,Ga,xe,Fh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> both<span class="token operator">:</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token string">'hello!'</span> <span class="token punctuation">&#125;</span></code>`,Ja,C,Rt,up,hp,jt,dp,yp,Vt,kp,fp,It,mp,wp,Mt,vp,bp,Ya,$,Ep,Ht,gp,_p,za,Be,Qh='<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> AUrlState <span class="token operator">&amp;</span> BUrlState <span class="token operator">&amp;</span> CUrlState</code>',Za,ee,Cp,Wt,Op,Tp,Na,rt,Up,Xa,te,xp,Ft,Bp,Dp,$a,De,qh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">StateForKeys<span class="token operator">&lt;</span>Keys <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>
<span class="token punctuation">&#125;</span></code>`,en,v,Ap,Qt,Pp,Kp,qt,Lp,Sp,Gt,Rp,jp,Jt,Vp,Ip,Yt,Mp,Hp,tn,Ae,Gh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">MyKeys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token string">'c'</span>
<span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> StateForKeys<span class="token operator">&lt;</span>MyKeys<span class="token operator">></span></code>`,sn,z,zt,Wp,Fp,Zt,Qp,qp,an,A,Gp,Nt,Jp,Yp,Xt,zp,Zp,$t,Np,Xp,nn,Pe,Jh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">BadKeys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token number">4</span>
<span class="token keyword">type</span> <span class="token class-name">AlsoBad</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token string">'c'</span></code>`,on,se,$p,es,el,tl,pn,ct,sl,ln,Ke,Yh='<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Values<span class="token operator">&lt;</span>Object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span></span> <span class="token operator">=</span> Object<span class="token punctuation">[</span><span class="token keyword">keyof</span> Object<span class="token punctuation">]</span></code>',rn,q,al,ts,nl,ol,ss,pl,ll,cn,it,rl,un,ae,cl,as,il,ul,hn,Le,zh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">KeysByValue<span class="token operator">&lt;</span>Object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> Value<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token keyword">keyof</span> Object<span class="token punctuation">]</span><span class="token operator">:</span> Object<span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Value</span> <span class="token operator">?</span> Key <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> Object<span class="token punctuation">]</span></code>`,dn,b,hl,ns,dl,yl,os,kl,fl,ps,ml,wl,ls,vl,bl,rs,El,gl,yn,O,_l,cs,Cl,Ol,is,Tl,Ul,us,xl,Bl,hs,Dl,Al,kn,E,Pl,ds,Kl,Ll,ys,Sl,Rl,ks,jl,Vl,fs,Il,Ml,ms,Hl,Wl,fn,Se,Zh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Mapping</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  a<span class="token operator">:</span> <span class="token builtin">boolean</span>
  b<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// resolves to 'no'</span>
<span class="token keyword">type</span> <span class="token class-name">Conditional</span> <span class="token operator">=</span> Mapping<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token string">'yes'</span> <span class="token operator">:</span> <span class="token string">'no'</span>

<span class="token comment">// resolves to 1 | 2 | 3</span>
<span class="token keyword">type</span> <span class="token class-name">OtherConditional</span> <span class="token operator">=</span> mapping<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> mapping<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span></code>`,mn,h,Fl,ws,Ql,ql,vs,Gl,Jl,bs,Yl,zl,Es,Zl,Nl,gs,Xl,$l,_s,er,tr,Cs,sr,ar,Os,nr,or,Ts,pr,lr,Us,rr,cr,xs,ir,ur,Bs,hr,dr,Ds,yr,kr,As,fr,mr,Ps,wr,vr,Ks,br,Er,Ls,gr,_r,wn,g,Cr,Ss,Or,Tr,Rs,Ur,xr,js,Br,Dr,Vs,Ar,Pr,Is,Kr,Lr,vn,ut,Sr,bn,ht,Rr,En,Re,Nh=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TempC</span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> <span class="token string">'degrees-celcius'</span> <span class="token punctuation">&#125;</span></code>`,gn,f,Ms,jr,Vr,Hs,Ir,Mr,Ws,Hr,Wr,Fs,Fr,Qr,Qs,qr,Gr,qs,Jr,Yr,Gs,zr,Zr,Js,Nr,Xr,_n,je,Xh='<code class="language-typescript"><span class="token keyword">const</span> freezing <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">as</span> TempC</code>',Cn,ne,$r,Ve,ec,tc,On,Ie,$h=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TempC</span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> <span class="token string">'degrees-c'</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> <span class="token class-name">TempF</span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> <span class="token string">'degrees-f'</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> <span class="token class-name">TempCExtendsNumber</span> <span class="token operator">=</span> TempC <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//true</span>
<span class="token keyword">type</span> <span class="token class-name">TempFExtendsNumber</span> <span class="token operator">=</span> TempF <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//true</span>
<span class="token keyword">type</span> <span class="token class-name">TempCIsNotTempF</span> <span class="token operator">=</span> TempC <span class="token keyword">extends</span> <span class="token class-name">TempF</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//false!</span></code>`,Tn,oe,sc,Ys,ac,nc,Un,Me,ed=`<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ThermometerUnits</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  home<span class="token operator">:</span> TempC
  car<span class="token operator">:</span> TempC
  school<span class="token operator">:</span> TempF
<span class="token punctuation">&#125;</span>

<span class="token comment">// 'home' | 'school'</span>
<span class="token keyword">type</span> <span class="token class-name">CelsiusThermometers</span> <span class="token operator">=</span> KeysByValue<span class="token operator">&lt;</span>ThermometerUnits<span class="token punctuation">,</span> TempC<span class="token operator">></span></code>`,xn,pe,oc,zs,pc,lc,Bn,He,td='<code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Value<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> Brand <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span></code>',Dn,G,rc,Zs,cc,ic,Ns,uc,hc,An,le,dc,Xs,yc,kc,Pn,We,sd=`<code class="language-typescript"><span class="token comment">// Type of the state accessible by a particular brand</span>
<span class="token keyword">type</span> <span class="token class-name">StateFor<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> Brands<span class="token operator">></span></span> <span class="token operator">=</span> PickByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> Value<span class="token operator">&lt;</span>Brand<span class="token operator">>></span></code>`,Kn,re,fc,$s,mc,wc,Ln,dt,vc,Sn,yt,bc,Rn,ce,Ec,ea,gc,_c,jn,Fe,ad='<code class="language-typescript"><span class="token keyword">const</span> _url_state_conforms <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> UrlState<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> Value<span class="token operator">&lt;</span>Brands<span class="token operator">></span> <span class="token punctuation">&#125;</span> <span class="token operator">=></span> state</code>',Vn,P,Cc,ta,Oc,Tc,sa,Uc,xc,aa,Bc,Dc,In,K,Ac,Qe,Pc,Kc,na,Lc,Sc,oa,Rc,jc,Mn,kt,Vc,Hn,qe,nd=`<code class="language-typescript"><span class="token comment">// only keys which are assigned to multiple brands will extend null | undefined.</span>
<span class="token comment">// Therefore this function has return type never</span>
<span class="token comment">// as long as no key is assigned to multiple brands.</span>
<span class="token keyword">const</span> _brands_dont_overlap <span class="token operator">=</span> <span class="token punctuation">(</span>
  keys_assigned_to_multiple_brands<span class="token operator">:</span> KeysByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=></span> keys_assigned_to_multiple_brands</code>`,Wn,_,Ic,pa,Mc,Hc,la,Wc,Fc,ra,Qc,qc,ca,Gc,Jc,ia,Yc,zc,Fn,T,Zc,ua,Nc,Xc,ha,$c,ei,da,ti,si,ya,ai,ni,Qn,ie,oi,Ge,pi,li;return{c(){k=o("p"),W=a("Search params in the URL are an underrated way to store state in react applications. While they can be somewhat less ergonomic than state from "),I=o("code"),me=a("useReducer"),m=a(", they have the major advantage of being more directly accessible to the user. This enables things like allowing the user to share links to their particular state, or allowing bookmarks to \u201Cremember\u201D state which would be forgotten on page reloads if it were stored within react. However, it is important to understand the various bumps and ugliness that come along with search params."),U=i(),M=o("p"),lo=a("Because the user has direct access to them, it\u2019s hard to make strong type guarantees about what you will find when decoding a URL, and so it is important to "),we=o("a"),ro=a("parse values"),co=a(" whenever you pull them out of the URL."),fa=i(),F=o("p"),io=a("Also, when multiple components in your application want to use search params you can run into race conditions that can be infuriating to debug. However, just because we can\u2019t make type level guarantees about the "),bt=o("em"),uo=a("values"),ho=a(" in the URL doesn\u2019t mean we can\u2019t make type level guarantees about the "),Et=o("em"),yo=a("keys"),ko=a(`. What\u2019s important here is to think carefully about what we want the type system to validate for us.
When multiple components use the URL search params:`),ma=i(),Z=o("ol"),gt=o("li"),fo=a("No two components should use the same keys (to avoid race conditions)"),mo=i(),_t=o("li"),wo=a("Each component should explicitly state which keys it uses (to make 1 possible)"),wa=i(),Q=o("p"),vo=a("A word of caution; this involves a "),Ct=o("em"),bo=a("lot"),Eo=a(" of fancy types; in fact, it\u2019s very close to using every typescript language feature that I\u2019m aware of, and several obscure patterns that aren\u2019t baked into the language. The great and powerful Dan Vanderkam is "),ve=o("a"),go=a("absolutely right"),_o=a(" that fancy types should be used sparingly, and can end up making things more complicated than they need to be. However, they can also allow you to make really specific guarantees with the type system that go way beyond simple type errors and start to make the type system feel like a real extension of your test suite. Also, they make you feel like a sorcerer."),va=i(),Ye=o("h2"),Co=a("Run time"),ba=i(),x=o("p"),Oo=a("Since most of the work here is about getting the type system to verify these properties for us, the runtime side of this is fairly simple. We want to create a new hook "),Ot=o("code"),To=a("useUrlParams"),Uo=a(" which will centralize interacting with the URL. This will deserialize the URL into an object and expose a wrapped version of the react router "),Tt=o("code"),xo=a("push"),Bo=a(" function that will take an object and only update those keys in the URL. "),Ut=o("code"),Do=a("null"),Ao=a(" will be interpreted as removing a value. Centralizing access to the URL in this way helps us make sure that we are interacting with that state in a consistent way, and would be good practice even if we didn\u2019t want the type guarantees. It gives us a single component which is responsible for mediating access to the state in the URL, so we don\u2019t have to implement things like the wrapped push function in every single component."),Ea=i(),ze=o("h2"),Po=a("Type time"),ga=i(),Ze=o("p"),Ko=a("This is the fun part. There\u2019s a lot of fancy types involved, so first we\u2019re going to present the whole thing together to see what the point is, and then we\u2019re going to dig into some of the more complicated signatures. If there\u2019s a signature you don\u2019t understand, stick with me and I\u2019ll try to name it and explain it a little further down."),_a=i(),be=o("pre"),Ca=i(),N=o("p"),Lo=a("Within a "),xt=o("code"),So=a("types"),Ro=a(" file for each component that wants to consume the URL, create a state type."),Oa=i(),Ee=o("pre"),Ta=i(),X=o("p"),jo=a("Within the implementation file for "),Bt=o("code"),Vo=a("useUrlParams"),Io=a(", we create a unified representation of the URL state across all components. This is where we will get type errors if multiple components attempt to use the same key in the URL."),Ua=i(),ge=o("pre"),xa=i(),B=o("p"),Mo=a("Finally, we can consume "),Dt=o("code"),Ho=a("useUrlParams"),Wo=a(" anywhere we want to access the URL. The important thing here is that because "),At=o("code"),Fo=a("useUrlParams"),Qo=a(" has a type parameter for "),Pt=o("code"),qo=a("Brand"),Go=a(", any attempt to access a key outside of your brand will be a type error, and any attempt to write to a key outside of your brand will be a type error. This gives us static enforcement that components won\u2019t be interfering with each others URL params."),Ba=i(),_e=o("pre"),Da=i(),Ne=o("p"),Jo=a("That\u2019s all that needs to go into each component file. The rest will be inferred by typescript."),Aa=i(),Xe=o("h2"),Yo=a("Fancy types"),Pa=i(),$e=o("p"),zo=a("This is all very nice, but I\u2019m using a lot of generic types, mapped types, conditional types, and type level proofs. These things don\u2019t come up very often in day to day code, and plenty of people use typescript to great effect without understanding them or even recognizing them. A lot of them are documented elsewhere, so mostly I\u2019m going to give quick overviews here for how I\u2019ve used them and give you the names you need to dig in further if you\u2019re interested."),Ka=i(),et=o("h3"),Zo=a("Mapped types"),La=i(),tt=o("p"),No=a("Mapped types let us derive new object types from old ones. For instance, when talking about the part of the URL that a single component needs we have a type that represents the union of keys the component is interested in. We want to get a type that is an object which maps those keys to values that could come out of the URL."),Sa=i(),Ce=o("pre"),Ra=i(),D=o("p"),Xo=a("This syntax says that "),Kt=o("code"),$o=a("UrlState"),ep=a(" is an object type which has a key for each possible value of the "),Lt=o("code"),tp=a("Keys"),sp=a(" type, and that all of it\u2019s keys are mapped to "),St=o("code"),ap=a("string | null | undefined"),np=a(". Then in runtime code we could use that type to know what we will be able to access;"),ja=i(),Oe=o("pre"),Va=i(),st=o("p"),op=a("Mapped types can reference the type of their keys as values. This is useful but hard to explain without some more fancy types, so just keep it in mind for now."),Ia=i(),Te=o("pre"),Ma=i(),at=o("h3"),pp=a("Type indexing"),Ha=i(),nt=o("p"),lp=a("When you have a type which has keys and values (like mapped types), you can \u2018index\u2019 into that type just like you would at runtime, to get the type under a particular key."),Wa=i(),Ue=o("pre"),Fa=i(),ot=o("p"),rp=a("This makes it much easier to work with mapped types to do a variety of flexible things."),Qa=i(),pt=o("h3"),cp=a("Intersection types"),qa=i(),lt=o("p"),ip=a("Intersection types are a way to talk about values which satisfy both of two distinct types."),Ga=i(),xe=o("pre"),Ja=i(),C=o("p"),Rt=o("code"),up=a("A"),hp=a(" describes things which map a key "),jt=o("code"),dp=a("a"),yp=a(" to a number, and "),Vt=o("code"),kp=a("B"),fp=a(" describes things which map a key "),It=o("code"),mp=a("b"),wp=a(" to a string. Of course, it\u2019s not hard to imagine a value that does both of these things, and the intersection operator "),Mt=o("code"),vp=a("&"),bp=a(" lets us construct the type of such things."),Ya=i(),$=o("p"),Ep=a("Like type indexing, this is rarely useful on it\u2019s own. But it does let us combine things that should be defined separately in a straightforward way. In the code above, one of the ways we use this is to construct the "),Ht=o("code"),gp=a("UrlState"),_p=a(" type by intersecting together the types provided by each of the individual components."),za=i(),Be=o("pre"),Za=i(),ee=o("p"),Cp=a("We did this so that we could define each of the component states in their own file, somewhere close to the component, and defer combining them together until we were writing the central "),Wt=o("code"),Op=a("useUrlParams"),Tp=a(" component."),Na=i(),rt=o("h3"),Up=a("Generic types"),Xa=i(),te=o("p"),xp=a("Generic types let us talk about whole sets of types that have the same structure. For instance, we want to be able to talk about something like "),Ft=o("code"),Bp=a("UrlState"),Dp=a(" for each component that needs to access the URL. We can do this with a generic type."),$a=i(),De=o("pre"),en=i(),v=o("p"),Ap=a("This looks a lot like the "),Qt=o("code"),Pp=a("UrlState"),Kp=a(" type above, except for that stuff in angle brackets; "),qt=o("code"),Lp=a("<Keys extends string>"),Sp=a(". This is called a "),Gt=o("em"),Rp=a("type parameter"),jp=a(". It acts a bit like an argument list, in the sense that it introduces the name of a new type "),Jt=o("code"),Vp=a("Keys"),Ip=a(" which can then be referenced on the other side of the equals sign. When we want to get a concrete type, we use angle brackets again to specify what the particular type of "),Yt=o("code"),Mp=a("Keys"),Hp=a(" should be."),tn=i(),Ae=o("pre"),sn=i(),z=o("p"),zt=o("code"),Wp=a("UrlState"),Fp=a(" defined this way will be exactly the same as "),Zt=o("code"),Qp=a("UrlState"),qp=a(" above, but just like functions allow us to reuse code, generics allow us to reuse types."),an=i(),A=o("p"),Gp=a("Type parameters can also have restrictions on them to specify that they can\u2019t be any type, but have to satisfy some particular bound. In our example above, "),Nt=o("code"),Jp=a("<Keys extends string>"),Yp=a(" says that any parameter provided for "),Xt=o("code"),zp=a("Keys"),Zp=a(" must only have values which are also values of the "),$t=o("code"),Np=a("string"),Xp=a(" type."),nn=i(),Pe=o("pre"),on=i(),se=o("p"),$p=a("Both of these types have some values which are not strings, and so trying to use them as a parameter to "),es=o("code"),el=a("StateForKeys"),tl=a(" would result in a type error. In that sense, these restrictions are like type signatures on normal runtime functions."),pn=i(),ct=o("p"),sl=a("Combining this with type indexing, we could create a generic type which gives us the values of any object."),ln=i(),Ke=o("pre"),rn=i(),q=o("p"),al=a("This says that given any type "),ts=o("code"),nl=a("Object"),ol=a(" which can have keys and values, we want the result of indexing into "),ss=o("code"),pl=a("Object"),ll=a(" with any of its keys. In other words, the union of all its values."),cn=i(),it=o("h3"),rl=a("Conditional types"),un=i(),ae=o("p"),cl=a("Conditional types let us check something about a type and result in a different type depending on that check, just like ternaries do at runtime. For instance, in the full code above we have a "),as=o("code"),il=a("KeysByValue"),ul=a(" type which we use to get all of the keys of an object type which are mapped to certain sorts of values."),hn=i(),Le=o("pre"),dn=i(),b=o("p"),hl=a("This builds on both of the thigns we discussed above and introduces some new ones, so lets break it down. "),ns=o("code"),dl=a("KeysByValue"),yl=a(" is a generic type, because it has type parameters; "),os=o("code"),kl=a("<Object extends {}, Value>"),fl=a(". This means that on the other side of the equals sign we will be able to reference "),ps=o("code"),ml=a("Object"),wl=a(", which we know "),ls=o("code"),vl=a("extends {}"),bl=a(". That means it can be anything at all as long as that thing can have keys and values. We will also be able to reference "),rs=o("code"),El=a("Value"),gl=a(", which has no restrictions at all."),yn=i(),O=o("p"),_l=a("On the other side of the equals sign we define "),cs=o("code"),Cl=a("KeysByValue"),Ol=a(" as a mapped type. Before the colon we have "),is=o("code"),Tl=a("[Key in keyof Object]"),Ul=a(". "),us=o("code"),xl=a("keyof Object"),Bl=a(" means that the keys of this type will be the same as the keys of whatever we supply as the "),hs=o("code"),Dl=a("Object"),Al=a(" type."),kn=i(),E=o("p"),Pl=a("After the colon we have our conditional type, "),ds=o("code"),Kl=a("Object[Key] extends Value ? Key : never"),Ll=a(". This looks a lot like a ternary, and can be interpreted in a very similar way. First, we have our condition; "),ys=o("code"),Sl=a("Object[Key] extends Value"),Rl=a(". In english, this will be true if the value of the type "),ks=o("code"),jl=a("Object"),Vl=a(" indexed by something of the type "),fs=o("code"),Il=a("Key"),Ml=a(" satisfies the type "),ms=o("code"),Hl=a("Value"),Wl=a("."),fn=i(),Se=o("pre"),mn=i(),h=o("p"),Fl=a("In our "),ws=o("code"),Ql=a("KeysByValue"),ql=a(" type, we check whether the value of "),vs=o("code"),Gl=a("Object"),Jl=a(" at "),bs=o("code"),Yl=a("Key"),zl=a(" extends "),Es=o("code"),Zl=a("Value"),Nl=a(", and if it does we give back the type "),gs=o("code"),Xl=a("Key"),$l=a(". If it doesn\u2019t we give back "),_s=o("code"),er=a("never"),tr=a(". "),Cs=o("code"),sr=a("never"),ar=a(" is a special type which has no values. That is, there is no thing at runtime that can be typed as "),Os=o("code"),nr=a("never"),or=a(". The reason that is useful is that anything unioned with "),Ts=o("code"),pr=a("never"),lr=a(" is just itself; "),Us=o("code"),rr=a("number | never"),cr=a(" is "),xs=o("code"),ir=a("number"),ur=a(", "),Bs=o("code"),hr=a("string | never"),dr=a(" is "),Ds=o("code"),yr=a("string"),kr=a(`, etc.
That is useful here because the last thing we do is index into the whole mapped type by `),As=o("code"),fr=a("keyof Object"),mr=a(" to get the union of all of the mapped values. Any of the values which get mapped to "),Ps=o("code"),wr=a("never"),vr=a(" just disappear, so what we\u2019re left with is a union of the "),Ks=o("em"),br=a("subset"),Er=a(" of keys which have values that extend "),Ls=o("code"),gr=a("Value"),_r=a("."),wn=i(),g=o("p"),Cr=a("So in english, "),Ss=o("code"),Or=a("KeysByValue"),Tr=a(" says that for any "),Rs=o("code"),Ur=a("Object"),xr=a(" type and "),js=o("code"),Br=a("Value"),Dr=a(" type, it gives back the union of all keys which are mapped to something that "),Vs=o("code"),Ar=a("extends Value"),Pr=a(". Conditional types are harder to grasp than a lot of the other fancy types, because they are "),Is=o("em"),Kr=a("extremely"),Lr=a(" situational, so think about what this does for us in the URL example. We use this to tell apart the keys used by various different components based on their brand. But what\u2019s a brand?"),vn=i(),ut=o("h3"),Sr=a("Branded types"),bn=i(),ht=o("p"),Rr=a("All of our fancy types so far have been language features of typescript. Branded types are a little different. Branding is a pattern used to prevent typescript from recognizing two types as the same."),En=i(),Re=o("pre"),gn=i(),f=o("p"),Ms=o("code"),jr=a("TempC"),Vr=a(" is the "),Hs=o("em"),Ir=a("intersection"),Mr=a(" of "),Ws=o("code"),Hr=a("number"),Wr=a(" and "),Fs=o("code"),Fr=a("{_brand: 'degrees-celcius'}"),Qr=a(". Intersection types are interpreted as being "),Qs=o("em"),qr=a("both"),Gr=a(" of the things on either side of the "),qs=o("code"),Jr=a("&"),Yr=a(". So "),Gs=o("code"),zr=a("TempC"),Zr=a(" can be used whenever a number could be used, and also whenever "),Js=o("code"),Nr=a("{_brand: 'degrees-celcius'}"),Xr=a(" could be used. However, at runtime this is a pretty challenging thing to create, and involves casting a number into the branded type."),_n=i(),je=o("pre"),Cn=i(),ne=o("p"),$r=a("Branding is often used to "),Ve=o("a"),ec=a("restrict the usage of a value"),tc=a(" to the context where it makes sense. We use them a little differently in the URL example. Instead, we\u2019re leaning on the fact that branded types don\u2019t extend each other."),On=i(),Ie=o("pre"),Tn=i(),oe=o("p"),sc=a("Branded types extend their underlying type, but they don\u2019t extend each other. This is especially useful in the context of our "),Ys=o("code"),ac=a("KeysByValue"),nc=a(" type, because if our values are branded we can retrieve all of the things with a particular brand."),Un=i(),Me=o("pre"),xn=i(),pe=o("p"),oc=a("In our URL use case we use brands to identify all of the keys that come from a particular component. In fact, we define a "),zs=o("code"),pc=a("Value"),lc=a(" type for what values can be retrieved from a URL that has to carry a brand."),Bn=i(),He=o("pre"),Dn=i(),G=o("p"),rc=a("This says that given some branding string, values in the URL are either a branded string ("),Zs=o("code"),cc=a("string & {_brand: Brand}"),ic=a(") or they are null or undefined. This is a little quirky, but the structure there is necessary becase null and undefined "),Ns=o("em"),uc=a("cannot"),hc=a(" be branded."),An=i(),le=o("p"),dc=a("We then use this branding of values to define a type which gives us the slice of the state accessible to a given component, which is what powers the signature of "),Xs=o("code"),yc=a("useUrlParams"),kc=a("."),Pn=i(),We=o("pre"),Kn=i(),re=o("p"),fc=a("This has real value, in that it makes sure that a component only accesses the keys that it claims it will access. But that\u2019s not all I claimed that this URL code could do; I also said that if two components both tried to claim the same key, that would cause a type error. To get that guarantee we need "),$s=o("em"),mc=a("one"),wc=a(" more fancy type."),Ln=i(),dt=o("h3"),vc=a("Type level proofs"),Sn=i(),yt=o("p"),bc=a("One way to think about typescript is that it is a system that lets you specify additional information about your javascript code to identify (in the form of type errors) when that code does something that you think should be illegal. Usually this is things like adding a number to an object, or trying to access a key that doesn\u2019t exist. However, sometimes we want to be able to specify other sorts of restrictions that are not traditionally thought of as type errors."),Rn=i(),ce=o("p"),Ec=a("For instance, the way this code is set up each individual component makes up a state type that gets intersectioned in to the overall URL state. We assume that this is done correctly, and that each component provides a state type that maps string keys to branded values. But what if we wanted to make it so that there would be a type error if we had done this wrong? What we want is something that will cause a type error if (and only if) the URL state doesn\u2019t extend "),ea=o("code"),gc=a("{[Key in string]: Value<Brands>}"),_c=a(". It turns out, what we want is a function."),jn=i(),Fe=o("pre"),Vn=i(),P=o("p"),Cc=a("This function says that given any argument of type "),ta=o("code"),Oc=a("UrlState"),Tc=a(", it will return the type we want, and is implemented as the identity function; that is, it just returns its argument without modification. What that must mean is that any object which is of type "),sa=o("code"),Uc=a("UrlState"),xc=a(" is also of type "),aa=o("code"),Bc=a("{[Key in string]: Value<Brands>}"),Dc=a(", because if that weren\u2019t true we would get a type error showing us where this might fail."),In=i(),K=o("p"),Ac=a("I call functions of this form \u201Ctype level proofs\u201D, because of some very "),Qe=o("a"),Pc=a("esoteric"),Kc=a(" mathematics, but another way to think about them is type level "),na=o("em"),Lc=a("tests"),Sc=a(". Just like tests, these are functions which are not used in production code, and only exist to verify that the code we have written satisfies some constraint. The main difference is that rather than the constraint being a runtime assertion, it happens at type time and can prove that something is true for "),oa=o("em"),Rc=a("any possible argument"),jc=a(", rather than just the examples we happen to test."),Mn=i(),kt=o("p"),Vc=a("Now, to sum it all up, we want to guarantee that there are no keys which are used by multiple different components."),Hn=i(),qe=o("pre"),Wn=i(),_=o("p"),Ic=a("Same basic thing; an identity function with some input type and some output type. Here, we are using the function to check that anything of type "),pa=o("code"),Mc=a("KeysByValue<UrlState, null | undefined>"),Hc=a(" (keys of "),la=o("code"),Wc=a("UrlState"),Fc=a(" which are mapped to "),ra=o("code"),Qc=a("null | undefined"),qc=a(" rather than being mapped to "),ca=o("code"),Gc=a("Value<Brand>"),Jc=a(") is of type "),ia=o("code"),Yc=a("never"),zc=a("."),Fn=i(),T=o("p"),Zc=a("That\u2019s a little strange, since "),ua=o("code"),Nc=a("never"),Xc=a(" is defined as a type which has no values. Then another way to interpret this function is that it is claiming that there are "),ha=o("em"),$c=a("no values"),ei=a(" which satisfy "),da=o("code"),ti=a("KeysByValue<UrlState, null | undefined>"),si=a(". Since a key would satisfy that type if and only if it had been assigned to multiple brands, this will cause a type error if there is any key with multiple brands because the return type will be the union of such keys rather than "),ya=o("code"),ai=a("never"),ni=a("."),Qn=i(),ie=o("p"),oi=a("That\u2019s it! those are all of the tools we use to get our guarantees. We use a type level proof to show that no two components register the same keys, and we use branding to guarantee that each component only accesses the keys that it registered. Now that you\u2019ve seen all of the fanciness, it\u2019s worth going back through the code at the top and seeing if the complex signatures make more sense now. I\u2019ve also set up a "),Ge=o("a"),pi=a("playground"),li=a(" where you can play around with a minimal version of the complete product, to see where type errors would appear if you break those guarantees and to see if you can get this to be any less eldritch nonsense than my version."),this.h()},l(e){k=p(e,"P",{});var r=l(k);W=n(r,"Search params in the URL are an underrated way to store state in react applications. While they can be somewhat less ergonomic than state from "),I=p(r,"CODE",{});var ci=l(I);me=n(ci,"useReducer"),ci.forEach(s),m=n(r,", they have the major advantage of being more directly accessible to the user. This enables things like allowing the user to share links to their particular state, or allowing bookmarks to \u201Cremember\u201D state which would be forgotten on page reloads if it were stored within react. However, it is important to understand the various bumps and ugliness that come along with search params."),r.forEach(s),U=u(e),M=p(e,"P",{});var qn=l(M);lo=n(qn,"Because the user has direct access to them, it\u2019s hard to make strong type guarantees about what you will find when decoding a URL, and so it is important to "),we=p(qn,"A",{href:!0,rel:!0});var ii=l(we);ro=n(ii,"parse values"),ii.forEach(s),co=n(qn," whenever you pull them out of the URL."),qn.forEach(s),fa=u(e),F=p(e,"P",{});var ft=l(F);io=n(ft,"Also, when multiple components in your application want to use search params you can run into race conditions that can be infuriating to debug. However, just because we can\u2019t make type level guarantees about the "),bt=p(ft,"EM",{});var ui=l(bt);uo=n(ui,"values"),ui.forEach(s),ho=n(ft," in the URL doesn\u2019t mean we can\u2019t make type level guarantees about the "),Et=p(ft,"EM",{});var hi=l(Et);yo=n(hi,"keys"),hi.forEach(s),ko=n(ft,`. What\u2019s important here is to think carefully about what we want the type system to validate for us.
When multiple components use the URL search params:`),ft.forEach(s),ma=u(e),Z=p(e,"OL",{});var Gn=l(Z);gt=p(Gn,"LI",{});var di=l(gt);fo=n(di,"No two components should use the same keys (to avoid race conditions)"),di.forEach(s),mo=u(Gn),_t=p(Gn,"LI",{});var yi=l(_t);wo=n(yi,"Each component should explicitly state which keys it uses (to make 1 possible)"),yi.forEach(s),Gn.forEach(s),wa=u(e),Q=p(e,"P",{});var mt=l(Q);vo=n(mt,"A word of caution; this involves a "),Ct=p(mt,"EM",{});var ki=l(Ct);bo=n(ki,"lot"),ki.forEach(s),Eo=n(mt," of fancy types; in fact, it\u2019s very close to using every typescript language feature that I\u2019m aware of, and several obscure patterns that aren\u2019t baked into the language. The great and powerful Dan Vanderkam is "),ve=p(mt,"A",{href:!0,rel:!0});var fi=l(ve);go=n(fi,"absolutely right"),fi.forEach(s),_o=n(mt," that fancy types should be used sparingly, and can end up making things more complicated than they need to be. However, they can also allow you to make really specific guarantees with the type system that go way beyond simple type errors and start to make the type system feel like a real extension of your test suite. Also, they make you feel like a sorcerer."),mt.forEach(s),va=u(e),Ye=p(e,"H2",{});var mi=l(Ye);Co=n(mi,"Run time"),mi.forEach(s),ba=u(e),x=p(e,"P",{});var ue=l(x);Oo=n(ue,"Since most of the work here is about getting the type system to verify these properties for us, the runtime side of this is fairly simple. We want to create a new hook "),Ot=p(ue,"CODE",{});var wi=l(Ot);To=n(wi,"useUrlParams"),wi.forEach(s),Uo=n(ue," which will centralize interacting with the URL. This will deserialize the URL into an object and expose a wrapped version of the react router "),Tt=p(ue,"CODE",{});var vi=l(Tt);xo=n(vi,"push"),vi.forEach(s),Bo=n(ue," function that will take an object and only update those keys in the URL. "),Ut=p(ue,"CODE",{});var bi=l(Ut);Do=n(bi,"null"),bi.forEach(s),Ao=n(ue," will be interpreted as removing a value. Centralizing access to the URL in this way helps us make sure that we are interacting with that state in a consistent way, and would be good practice even if we didn\u2019t want the type guarantees. It gives us a single component which is responsible for mediating access to the state in the URL, so we don\u2019t have to implement things like the wrapped push function in every single component."),ue.forEach(s),Ea=u(e),ze=p(e,"H2",{});var Ei=l(ze);Po=n(Ei,"Type time"),Ei.forEach(s),ga=u(e),Ze=p(e,"P",{});var gi=l(Ze);Ko=n(gi,"This is the fun part. There\u2019s a lot of fancy types involved, so first we\u2019re going to present the whole thing together to see what the point is, and then we\u2019re going to dig into some of the more complicated signatures. If there\u2019s a signature you don\u2019t understand, stick with me and I\u2019ll try to name it and explain it a little further down."),gi.forEach(s),_a=u(e),be=p(e,"PRE",{class:!0});var od=l(be);od.forEach(s),Ca=u(e),N=p(e,"P",{});var Jn=l(N);Lo=n(Jn,"Within a "),xt=p(Jn,"CODE",{});var _i=l(xt);So=n(_i,"types"),_i.forEach(s),Ro=n(Jn," file for each component that wants to consume the URL, create a state type."),Jn.forEach(s),Oa=u(e),Ee=p(e,"PRE",{class:!0});var pd=l(Ee);pd.forEach(s),Ta=u(e),X=p(e,"P",{});var Yn=l(X);jo=n(Yn,"Within the implementation file for "),Bt=p(Yn,"CODE",{});var Ci=l(Bt);Vo=n(Ci,"useUrlParams"),Ci.forEach(s),Io=n(Yn,", we create a unified representation of the URL state across all components. This is where we will get type errors if multiple components attempt to use the same key in the URL."),Yn.forEach(s),Ua=u(e),ge=p(e,"PRE",{class:!0});var ld=l(ge);ld.forEach(s),xa=u(e),B=p(e,"P",{});var he=l(B);Mo=n(he,"Finally, we can consume "),Dt=p(he,"CODE",{});var Oi=l(Dt);Ho=n(Oi,"useUrlParams"),Oi.forEach(s),Wo=n(he," anywhere we want to access the URL. The important thing here is that because "),At=p(he,"CODE",{});var Ti=l(At);Fo=n(Ti,"useUrlParams"),Ti.forEach(s),Qo=n(he," has a type parameter for "),Pt=p(he,"CODE",{});var Ui=l(Pt);qo=n(Ui,"Brand"),Ui.forEach(s),Go=n(he,", any attempt to access a key outside of your brand will be a type error, and any attempt to write to a key outside of your brand will be a type error. This gives us static enforcement that components won\u2019t be interfering with each others URL params."),he.forEach(s),Ba=u(e),_e=p(e,"PRE",{class:!0});var rd=l(_e);rd.forEach(s),Da=u(e),Ne=p(e,"P",{});var xi=l(Ne);Jo=n(xi,"That\u2019s all that needs to go into each component file. The rest will be inferred by typescript."),xi.forEach(s),Aa=u(e),Xe=p(e,"H2",{});var Bi=l(Xe);Yo=n(Bi,"Fancy types"),Bi.forEach(s),Pa=u(e),$e=p(e,"P",{});var Di=l($e);zo=n(Di,"This is all very nice, but I\u2019m using a lot of generic types, mapped types, conditional types, and type level proofs. These things don\u2019t come up very often in day to day code, and plenty of people use typescript to great effect without understanding them or even recognizing them. A lot of them are documented elsewhere, so mostly I\u2019m going to give quick overviews here for how I\u2019ve used them and give you the names you need to dig in further if you\u2019re interested."),Di.forEach(s),Ka=u(e),et=p(e,"H3",{});var Ai=l(et);Zo=n(Ai,"Mapped types"),Ai.forEach(s),La=u(e),tt=p(e,"P",{});var Pi=l(tt);No=n(Pi,"Mapped types let us derive new object types from old ones. For instance, when talking about the part of the URL that a single component needs we have a type that represents the union of keys the component is interested in. We want to get a type that is an object which maps those keys to values that could come out of the URL."),Pi.forEach(s),Sa=u(e),Ce=p(e,"PRE",{class:!0});var cd=l(Ce);cd.forEach(s),Ra=u(e),D=p(e,"P",{});var de=l(D);Xo=n(de,"This syntax says that "),Kt=p(de,"CODE",{});var Ki=l(Kt);$o=n(Ki,"UrlState"),Ki.forEach(s),ep=n(de," is an object type which has a key for each possible value of the "),Lt=p(de,"CODE",{});var Li=l(Lt);tp=n(Li,"Keys"),Li.forEach(s),sp=n(de," type, and that all of it\u2019s keys are mapped to "),St=p(de,"CODE",{});var Si=l(St);ap=n(Si,"string | null | undefined"),Si.forEach(s),np=n(de,". Then in runtime code we could use that type to know what we will be able to access;"),de.forEach(s),ja=u(e),Oe=p(e,"PRE",{class:!0});var id=l(Oe);id.forEach(s),Va=u(e),st=p(e,"P",{});var Ri=l(st);op=n(Ri,"Mapped types can reference the type of their keys as values. This is useful but hard to explain without some more fancy types, so just keep it in mind for now."),Ri.forEach(s),Ia=u(e),Te=p(e,"PRE",{class:!0});var ud=l(Te);ud.forEach(s),Ma=u(e),at=p(e,"H3",{});var ji=l(at);pp=n(ji,"Type indexing"),ji.forEach(s),Ha=u(e),nt=p(e,"P",{});var Vi=l(nt);lp=n(Vi,"When you have a type which has keys and values (like mapped types), you can \u2018index\u2019 into that type just like you would at runtime, to get the type under a particular key."),Vi.forEach(s),Wa=u(e),Ue=p(e,"PRE",{class:!0});var hd=l(Ue);hd.forEach(s),Fa=u(e),ot=p(e,"P",{});var Ii=l(ot);rp=n(Ii,"This makes it much easier to work with mapped types to do a variety of flexible things."),Ii.forEach(s),Qa=u(e),pt=p(e,"H3",{});var Mi=l(pt);cp=n(Mi,"Intersection types"),Mi.forEach(s),qa=u(e),lt=p(e,"P",{});var Hi=l(lt);ip=n(Hi,"Intersection types are a way to talk about values which satisfy both of two distinct types."),Hi.forEach(s),Ga=u(e),xe=p(e,"PRE",{class:!0});var dd=l(xe);dd.forEach(s),Ja=u(e),C=p(e,"P",{});var H=l(C);Rt=p(H,"CODE",{});var Wi=l(Rt);up=n(Wi,"A"),Wi.forEach(s),hp=n(H," describes things which map a key "),jt=p(H,"CODE",{});var Fi=l(jt);dp=n(Fi,"a"),Fi.forEach(s),yp=n(H," to a number, and "),Vt=p(H,"CODE",{});var Qi=l(Vt);kp=n(Qi,"B"),Qi.forEach(s),fp=n(H," describes things which map a key "),It=p(H,"CODE",{});var qi=l(It);mp=n(qi,"b"),qi.forEach(s),wp=n(H," to a string. Of course, it\u2019s not hard to imagine a value that does both of these things, and the intersection operator "),Mt=p(H,"CODE",{});var Gi=l(Mt);vp=n(Gi,"&"),Gi.forEach(s),bp=n(H," lets us construct the type of such things."),H.forEach(s),Ya=u(e),$=p(e,"P",{});var zn=l($);Ep=n(zn,"Like type indexing, this is rarely useful on it\u2019s own. But it does let us combine things that should be defined separately in a straightforward way. In the code above, one of the ways we use this is to construct the "),Ht=p(zn,"CODE",{});var Ji=l(Ht);gp=n(Ji,"UrlState"),Ji.forEach(s),_p=n(zn," type by intersecting together the types provided by each of the individual components."),zn.forEach(s),za=u(e),Be=p(e,"PRE",{class:!0});var yd=l(Be);yd.forEach(s),Za=u(e),ee=p(e,"P",{});var Zn=l(ee);Cp=n(Zn,"We did this so that we could define each of the component states in their own file, somewhere close to the component, and defer combining them together until we were writing the central "),Wt=p(Zn,"CODE",{});var Yi=l(Wt);Op=n(Yi,"useUrlParams"),Yi.forEach(s),Tp=n(Zn," component."),Zn.forEach(s),Na=u(e),rt=p(e,"H3",{});var zi=l(rt);Up=n(zi,"Generic types"),zi.forEach(s),Xa=u(e),te=p(e,"P",{});var Nn=l(te);xp=n(Nn,"Generic types let us talk about whole sets of types that have the same structure. For instance, we want to be able to talk about something like "),Ft=p(Nn,"CODE",{});var Zi=l(Ft);Bp=n(Zi,"UrlState"),Zi.forEach(s),Dp=n(Nn," for each component that needs to access the URL. We can do this with a generic type."),Nn.forEach(s),$a=u(e),De=p(e,"PRE",{class:!0});var kd=l(De);kd.forEach(s),en=u(e),v=p(e,"P",{});var L=l(v);Ap=n(L,"This looks a lot like the "),Qt=p(L,"CODE",{});var Ni=l(Qt);Pp=n(Ni,"UrlState"),Ni.forEach(s),Kp=n(L," type above, except for that stuff in angle brackets; "),qt=p(L,"CODE",{});var Xi=l(qt);Lp=n(Xi,"<Keys extends string>"),Xi.forEach(s),Sp=n(L,". This is called a "),Gt=p(L,"EM",{});var $i=l(Gt);Rp=n($i,"type parameter"),$i.forEach(s),jp=n(L,". It acts a bit like an argument list, in the sense that it introduces the name of a new type "),Jt=p(L,"CODE",{});var eu=l(Jt);Vp=n(eu,"Keys"),eu.forEach(s),Ip=n(L," which can then be referenced on the other side of the equals sign. When we want to get a concrete type, we use angle brackets again to specify what the particular type of "),Yt=p(L,"CODE",{});var tu=l(Yt);Mp=n(tu,"Keys"),tu.forEach(s),Hp=n(L," should be."),L.forEach(s),tn=u(e),Ae=p(e,"PRE",{class:!0});var fd=l(Ae);fd.forEach(s),sn=u(e),z=p(e,"P",{});var ka=l(z);zt=p(ka,"CODE",{});var su=l(zt);Wp=n(su,"UrlState"),su.forEach(s),Fp=n(ka," defined this way will be exactly the same as "),Zt=p(ka,"CODE",{});var au=l(Zt);Qp=n(au,"UrlState"),au.forEach(s),qp=n(ka," above, but just like functions allow us to reuse code, generics allow us to reuse types."),ka.forEach(s),an=u(e),A=p(e,"P",{});var ye=l(A);Gp=n(ye,"Type parameters can also have restrictions on them to specify that they can\u2019t be any type, but have to satisfy some particular bound. In our example above, "),Nt=p(ye,"CODE",{});var nu=l(Nt);Jp=n(nu,"<Keys extends string>"),nu.forEach(s),Yp=n(ye," says that any parameter provided for "),Xt=p(ye,"CODE",{});var ou=l(Xt);zp=n(ou,"Keys"),ou.forEach(s),Zp=n(ye," must only have values which are also values of the "),$t=p(ye,"CODE",{});var pu=l($t);Np=n(pu,"string"),pu.forEach(s),Xp=n(ye," type."),ye.forEach(s),nn=u(e),Pe=p(e,"PRE",{class:!0});var md=l(Pe);md.forEach(s),on=u(e),se=p(e,"P",{});var Xn=l(se);$p=n(Xn,"Both of these types have some values which are not strings, and so trying to use them as a parameter to "),es=p(Xn,"CODE",{});var lu=l(es);el=n(lu,"StateForKeys"),lu.forEach(s),tl=n(Xn," would result in a type error. In that sense, these restrictions are like type signatures on normal runtime functions."),Xn.forEach(s),pn=u(e),ct=p(e,"P",{});var ru=l(ct);sl=n(ru,"Combining this with type indexing, we could create a generic type which gives us the values of any object."),ru.forEach(s),ln=u(e),Ke=p(e,"PRE",{class:!0});var wd=l(Ke);wd.forEach(s),rn=u(e),q=p(e,"P",{});var wt=l(q);al=n(wt,"This says that given any type "),ts=p(wt,"CODE",{});var cu=l(ts);nl=n(cu,"Object"),cu.forEach(s),ol=n(wt," which can have keys and values, we want the result of indexing into "),ss=p(wt,"CODE",{});var iu=l(ss);pl=n(iu,"Object"),iu.forEach(s),ll=n(wt," with any of its keys. In other words, the union of all its values."),wt.forEach(s),cn=u(e),it=p(e,"H3",{});var uu=l(it);rl=n(uu,"Conditional types"),uu.forEach(s),un=u(e),ae=p(e,"P",{});var $n=l(ae);cl=n($n,"Conditional types let us check something about a type and result in a different type depending on that check, just like ternaries do at runtime. For instance, in the full code above we have a "),as=p($n,"CODE",{});var hu=l(as);il=n(hu,"KeysByValue"),hu.forEach(s),ul=n($n," type which we use to get all of the keys of an object type which are mapped to certain sorts of values."),$n.forEach(s),hn=u(e),Le=p(e,"PRE",{class:!0});var vd=l(Le);vd.forEach(s),dn=u(e),b=p(e,"P",{});var S=l(b);hl=n(S,"This builds on both of the thigns we discussed above and introduces some new ones, so lets break it down. "),ns=p(S,"CODE",{});var du=l(ns);dl=n(du,"KeysByValue"),du.forEach(s),yl=n(S," is a generic type, because it has type parameters; "),os=p(S,"CODE",{});var yu=l(os);kl=n(yu,"<Object extends {}, Value>"),yu.forEach(s),fl=n(S,". This means that on the other side of the equals sign we will be able to reference "),ps=p(S,"CODE",{});var ku=l(ps);ml=n(ku,"Object"),ku.forEach(s),wl=n(S,", which we know "),ls=p(S,"CODE",{});var fu=l(ls);vl=n(fu,"extends {}"),fu.forEach(s),bl=n(S,". That means it can be anything at all as long as that thing can have keys and values. We will also be able to reference "),rs=p(S,"CODE",{});var mu=l(rs);El=n(mu,"Value"),mu.forEach(s),gl=n(S,", which has no restrictions at all."),S.forEach(s),yn=u(e),O=p(e,"P",{});var J=l(O);_l=n(J,"On the other side of the equals sign we define "),cs=p(J,"CODE",{});var wu=l(cs);Cl=n(wu,"KeysByValue"),wu.forEach(s),Ol=n(J," as a mapped type. Before the colon we have "),is=p(J,"CODE",{});var vu=l(is);Tl=n(vu,"[Key in keyof Object]"),vu.forEach(s),Ul=n(J,". "),us=p(J,"CODE",{});var bu=l(us);xl=n(bu,"keyof Object"),bu.forEach(s),Bl=n(J," means that the keys of this type will be the same as the keys of whatever we supply as the "),hs=p(J,"CODE",{});var Eu=l(hs);Dl=n(Eu,"Object"),Eu.forEach(s),Al=n(J," type."),J.forEach(s),kn=u(e),E=p(e,"P",{});var R=l(E);Pl=n(R,"After the colon we have our conditional type, "),ds=p(R,"CODE",{});var gu=l(ds);Kl=n(gu,"Object[Key] extends Value ? Key : never"),gu.forEach(s),Ll=n(R,". This looks a lot like a ternary, and can be interpreted in a very similar way. First, we have our condition; "),ys=p(R,"CODE",{});var _u=l(ys);Sl=n(_u,"Object[Key] extends Value"),_u.forEach(s),Rl=n(R,". In english, this will be true if the value of the type "),ks=p(R,"CODE",{});var Cu=l(ks);jl=n(Cu,"Object"),Cu.forEach(s),Vl=n(R," indexed by something of the type "),fs=p(R,"CODE",{});var Ou=l(fs);Il=n(Ou,"Key"),Ou.forEach(s),Ml=n(R," satisfies the type "),ms=p(R,"CODE",{});var Tu=l(ms);Hl=n(Tu,"Value"),Tu.forEach(s),Wl=n(R,"."),R.forEach(s),fn=u(e),Se=p(e,"PRE",{class:!0});var bd=l(Se);bd.forEach(s),mn=u(e),h=p(e,"P",{});var d=l(h);Fl=n(d,"In our "),ws=p(d,"CODE",{});var Uu=l(ws);Ql=n(Uu,"KeysByValue"),Uu.forEach(s),ql=n(d," type, we check whether the value of "),vs=p(d,"CODE",{});var xu=l(vs);Gl=n(xu,"Object"),xu.forEach(s),Jl=n(d," at "),bs=p(d,"CODE",{});var Bu=l(bs);Yl=n(Bu,"Key"),Bu.forEach(s),zl=n(d," extends "),Es=p(d,"CODE",{});var Du=l(Es);Zl=n(Du,"Value"),Du.forEach(s),Nl=n(d,", and if it does we give back the type "),gs=p(d,"CODE",{});var Au=l(gs);Xl=n(Au,"Key"),Au.forEach(s),$l=n(d,". If it doesn\u2019t we give back "),_s=p(d,"CODE",{});var Pu=l(_s);er=n(Pu,"never"),Pu.forEach(s),tr=n(d,". "),Cs=p(d,"CODE",{});var Ku=l(Cs);sr=n(Ku,"never"),Ku.forEach(s),ar=n(d," is a special type which has no values. That is, there is no thing at runtime that can be typed as "),Os=p(d,"CODE",{});var Lu=l(Os);nr=n(Lu,"never"),Lu.forEach(s),or=n(d,". The reason that is useful is that anything unioned with "),Ts=p(d,"CODE",{});var Su=l(Ts);pr=n(Su,"never"),Su.forEach(s),lr=n(d," is just itself; "),Us=p(d,"CODE",{});var Ru=l(Us);rr=n(Ru,"number | never"),Ru.forEach(s),cr=n(d," is "),xs=p(d,"CODE",{});var ju=l(xs);ir=n(ju,"number"),ju.forEach(s),ur=n(d,", "),Bs=p(d,"CODE",{});var Vu=l(Bs);hr=n(Vu,"string | never"),Vu.forEach(s),dr=n(d," is "),Ds=p(d,"CODE",{});var Iu=l(Ds);yr=n(Iu,"string"),Iu.forEach(s),kr=n(d,`, etc.
That is useful here because the last thing we do is index into the whole mapped type by `),As=p(d,"CODE",{});var Mu=l(As);fr=n(Mu,"keyof Object"),Mu.forEach(s),mr=n(d," to get the union of all of the mapped values. Any of the values which get mapped to "),Ps=p(d,"CODE",{});var Hu=l(Ps);wr=n(Hu,"never"),Hu.forEach(s),vr=n(d," just disappear, so what we\u2019re left with is a union of the "),Ks=p(d,"EM",{});var Wu=l(Ks);br=n(Wu,"subset"),Wu.forEach(s),Er=n(d," of keys which have values that extend "),Ls=p(d,"CODE",{});var Fu=l(Ls);gr=n(Fu,"Value"),Fu.forEach(s),_r=n(d,"."),d.forEach(s),wn=u(e),g=p(e,"P",{});var j=l(g);Cr=n(j,"So in english, "),Ss=p(j,"CODE",{});var Qu=l(Ss);Or=n(Qu,"KeysByValue"),Qu.forEach(s),Tr=n(j," says that for any "),Rs=p(j,"CODE",{});var qu=l(Rs);Ur=n(qu,"Object"),qu.forEach(s),xr=n(j," type and "),js=p(j,"CODE",{});var Gu=l(js);Br=n(Gu,"Value"),Gu.forEach(s),Dr=n(j," type, it gives back the union of all keys which are mapped to something that "),Vs=p(j,"CODE",{});var Ju=l(Vs);Ar=n(Ju,"extends Value"),Ju.forEach(s),Pr=n(j,". Conditional types are harder to grasp than a lot of the other fancy types, because they are "),Is=p(j,"EM",{});var Yu=l(Is);Kr=n(Yu,"extremely"),Yu.forEach(s),Lr=n(j," situational, so think about what this does for us in the URL example. We use this to tell apart the keys used by various different components based on their brand. But what\u2019s a brand?"),j.forEach(s),vn=u(e),ut=p(e,"H3",{});var zu=l(ut);Sr=n(zu,"Branded types"),zu.forEach(s),bn=u(e),ht=p(e,"P",{});var Zu=l(ht);Rr=n(Zu,"All of our fancy types so far have been language features of typescript. Branded types are a little different. Branding is a pattern used to prevent typescript from recognizing two types as the same."),Zu.forEach(s),En=u(e),Re=p(e,"PRE",{class:!0});var Ed=l(Re);Ed.forEach(s),gn=u(e),f=p(e,"P",{});var w=l(f);Ms=p(w,"CODE",{});var Nu=l(Ms);jr=n(Nu,"TempC"),Nu.forEach(s),Vr=n(w," is the "),Hs=p(w,"EM",{});var Xu=l(Hs);Ir=n(Xu,"intersection"),Xu.forEach(s),Mr=n(w," of "),Ws=p(w,"CODE",{});var $u=l(Ws);Hr=n($u,"number"),$u.forEach(s),Wr=n(w," and "),Fs=p(w,"CODE",{});var eh=l(Fs);Fr=n(eh,"{_brand: 'degrees-celcius'}"),eh.forEach(s),Qr=n(w,". Intersection types are interpreted as being "),Qs=p(w,"EM",{});var th=l(Qs);qr=n(th,"both"),th.forEach(s),Gr=n(w," of the things on either side of the "),qs=p(w,"CODE",{});var sh=l(qs);Jr=n(sh,"&"),sh.forEach(s),Yr=n(w,". So "),Gs=p(w,"CODE",{});var ah=l(Gs);zr=n(ah,"TempC"),ah.forEach(s),Zr=n(w," can be used whenever a number could be used, and also whenever "),Js=p(w,"CODE",{});var nh=l(Js);Nr=n(nh,"{_brand: 'degrees-celcius'}"),nh.forEach(s),Xr=n(w," could be used. However, at runtime this is a pretty challenging thing to create, and involves casting a number into the branded type."),w.forEach(s),_n=u(e),je=p(e,"PRE",{class:!0});var gd=l(je);gd.forEach(s),Cn=u(e),ne=p(e,"P",{});var eo=l(ne);$r=n(eo,"Branding is often used to "),Ve=p(eo,"A",{href:!0,rel:!0});var oh=l(Ve);ec=n(oh,"restrict the usage of a value"),oh.forEach(s),tc=n(eo," to the context where it makes sense. We use them a little differently in the URL example. Instead, we\u2019re leaning on the fact that branded types don\u2019t extend each other."),eo.forEach(s),On=u(e),Ie=p(e,"PRE",{class:!0});var _d=l(Ie);_d.forEach(s),Tn=u(e),oe=p(e,"P",{});var to=l(oe);sc=n(to,"Branded types extend their underlying type, but they don\u2019t extend each other. This is especially useful in the context of our "),Ys=p(to,"CODE",{});var ph=l(Ys);ac=n(ph,"KeysByValue"),ph.forEach(s),nc=n(to," type, because if our values are branded we can retrieve all of the things with a particular brand."),to.forEach(s),Un=u(e),Me=p(e,"PRE",{class:!0});var Cd=l(Me);Cd.forEach(s),xn=u(e),pe=p(e,"P",{});var so=l(pe);oc=n(so,"In our URL use case we use brands to identify all of the keys that come from a particular component. In fact, we define a "),zs=p(so,"CODE",{});var lh=l(zs);pc=n(lh,"Value"),lh.forEach(s),lc=n(so," type for what values can be retrieved from a URL that has to carry a brand."),so.forEach(s),Bn=u(e),He=p(e,"PRE",{class:!0});var Od=l(He);Od.forEach(s),Dn=u(e),G=p(e,"P",{});var vt=l(G);rc=n(vt,"This says that given some branding string, values in the URL are either a branded string ("),Zs=p(vt,"CODE",{});var rh=l(Zs);cc=n(rh,"string & {_brand: Brand}"),rh.forEach(s),ic=n(vt,") or they are null or undefined. This is a little quirky, but the structure there is necessary becase null and undefined "),Ns=p(vt,"EM",{});var ch=l(Ns);uc=n(ch,"cannot"),ch.forEach(s),hc=n(vt," be branded."),vt.forEach(s),An=u(e),le=p(e,"P",{});var ao=l(le);dc=n(ao,"We then use this branding of values to define a type which gives us the slice of the state accessible to a given component, which is what powers the signature of "),Xs=p(ao,"CODE",{});var ih=l(Xs);yc=n(ih,"useUrlParams"),ih.forEach(s),kc=n(ao,"."),ao.forEach(s),Pn=u(e),We=p(e,"PRE",{class:!0});var Td=l(We);Td.forEach(s),Kn=u(e),re=p(e,"P",{});var no=l(re);fc=n(no,"This has real value, in that it makes sure that a component only accesses the keys that it claims it will access. But that\u2019s not all I claimed that this URL code could do; I also said that if two components both tried to claim the same key, that would cause a type error. To get that guarantee we need "),$s=p(no,"EM",{});var uh=l($s);mc=n(uh,"one"),uh.forEach(s),wc=n(no," more fancy type."),no.forEach(s),Ln=u(e),dt=p(e,"H3",{});var hh=l(dt);vc=n(hh,"Type level proofs"),hh.forEach(s),Sn=u(e),yt=p(e,"P",{});var dh=l(yt);bc=n(dh,"One way to think about typescript is that it is a system that lets you specify additional information about your javascript code to identify (in the form of type errors) when that code does something that you think should be illegal. Usually this is things like adding a number to an object, or trying to access a key that doesn\u2019t exist. However, sometimes we want to be able to specify other sorts of restrictions that are not traditionally thought of as type errors."),dh.forEach(s),Rn=u(e),ce=p(e,"P",{});var oo=l(ce);Ec=n(oo,"For instance, the way this code is set up each individual component makes up a state type that gets intersectioned in to the overall URL state. We assume that this is done correctly, and that each component provides a state type that maps string keys to branded values. But what if we wanted to make it so that there would be a type error if we had done this wrong? What we want is something that will cause a type error if (and only if) the URL state doesn\u2019t extend "),ea=p(oo,"CODE",{});var yh=l(ea);gc=n(yh,"{[Key in string]: Value<Brands>}"),yh.forEach(s),_c=n(oo,". It turns out, what we want is a function."),oo.forEach(s),jn=u(e),Fe=p(e,"PRE",{class:!0});var Ud=l(Fe);Ud.forEach(s),Vn=u(e),P=p(e,"P",{});var ke=l(P);Cc=n(ke,"This function says that given any argument of type "),ta=p(ke,"CODE",{});var kh=l(ta);Oc=n(kh,"UrlState"),kh.forEach(s),Tc=n(ke,", it will return the type we want, and is implemented as the identity function; that is, it just returns its argument without modification. What that must mean is that any object which is of type "),sa=p(ke,"CODE",{});var fh=l(sa);Uc=n(fh,"UrlState"),fh.forEach(s),xc=n(ke," is also of type "),aa=p(ke,"CODE",{});var mh=l(aa);Bc=n(mh,"{[Key in string]: Value<Brands>}"),mh.forEach(s),Dc=n(ke,", because if that weren\u2019t true we would get a type error showing us where this might fail."),ke.forEach(s),In=u(e),K=p(e,"P",{});var fe=l(K);Ac=n(fe,"I call functions of this form \u201Ctype level proofs\u201D, because of some very "),Qe=p(fe,"A",{href:!0,rel:!0});var wh=l(Qe);Pc=n(wh,"esoteric"),wh.forEach(s),Kc=n(fe," mathematics, but another way to think about them is type level "),na=p(fe,"EM",{});var vh=l(na);Lc=n(vh,"tests"),vh.forEach(s),Sc=n(fe,". Just like tests, these are functions which are not used in production code, and only exist to verify that the code we have written satisfies some constraint. The main difference is that rather than the constraint being a runtime assertion, it happens at type time and can prove that something is true for "),oa=p(fe,"EM",{});var bh=l(oa);Rc=n(bh,"any possible argument"),bh.forEach(s),jc=n(fe,", rather than just the examples we happen to test."),fe.forEach(s),Mn=u(e),kt=p(e,"P",{});var Eh=l(kt);Vc=n(Eh,"Now, to sum it all up, we want to guarantee that there are no keys which are used by multiple different components."),Eh.forEach(s),Hn=u(e),qe=p(e,"PRE",{class:!0});var xd=l(qe);xd.forEach(s),Wn=u(e),_=p(e,"P",{});var V=l(_);Ic=n(V,"Same basic thing; an identity function with some input type and some output type. Here, we are using the function to check that anything of type "),pa=p(V,"CODE",{});var gh=l(pa);Mc=n(gh,"KeysByValue<UrlState, null | undefined>"),gh.forEach(s),Hc=n(V," (keys of "),la=p(V,"CODE",{});var _h=l(la);Wc=n(_h,"UrlState"),_h.forEach(s),Fc=n(V," which are mapped to "),ra=p(V,"CODE",{});var Ch=l(ra);Qc=n(Ch,"null | undefined"),Ch.forEach(s),qc=n(V," rather than being mapped to "),ca=p(V,"CODE",{});var Oh=l(ca);Gc=n(Oh,"Value<Brand>"),Oh.forEach(s),Jc=n(V,") is of type "),ia=p(V,"CODE",{});var Th=l(ia);Yc=n(Th,"never"),Th.forEach(s),zc=n(V,"."),V.forEach(s),Fn=u(e),T=p(e,"P",{});var Y=l(T);Zc=n(Y,"That\u2019s a little strange, since "),ua=p(Y,"CODE",{});var Uh=l(ua);Nc=n(Uh,"never"),Uh.forEach(s),Xc=n(Y," is defined as a type which has no values. Then another way to interpret this function is that it is claiming that there are "),ha=p(Y,"EM",{});var xh=l(ha);$c=n(xh,"no values"),xh.forEach(s),ei=n(Y," which satisfy "),da=p(Y,"CODE",{});var Bh=l(da);ti=n(Bh,"KeysByValue<UrlState, null | undefined>"),Bh.forEach(s),si=n(Y,". Since a key would satisfy that type if and only if it had been assigned to multiple brands, this will cause a type error if there is any key with multiple brands because the return type will be the union of such keys rather than "),ya=p(Y,"CODE",{});var Dh=l(ya);ai=n(Dh,"never"),Dh.forEach(s),ni=n(Y,"."),Y.forEach(s),Qn=u(e),ie=p(e,"P",{});var po=l(ie);oi=n(po,"That\u2019s it! those are all of the tools we use to get our guarantees. We use a type level proof to show that no two components register the same keys, and we use branding to guarantee that each component only accesses the keys that it registered. Now that you\u2019ve seen all of the fanciness, it\u2019s worth going back through the code at the top and seeing if the complex signatures make more sense now. I\u2019ve also set up a "),Ge=p(po,"A",{href:!0,rel:!0});var Ah=l(Ge);pi=n(Ah,"playground"),Ah.forEach(s),li=n(po," where you can play around with a minimal version of the complete product, to see where type errors would appear if you break those guarantees and to see if you can get this to be any less eldritch nonsense than my version."),po.forEach(s),this.h()},h(){y(we,"href","https://www.pluralsight.com/tech-blog/taming-dynamic-data-in-typescript/"),y(we,"rel","nofollow"),y(ve,"href","https://effectivetypescript.com/2021/02/03/pet-peeves/"),y(ve,"rel","nofollow"),y(be,"class","language-typescript"),y(Ee,"class","language-typescript"),y(ge,"class","language-typescript"),y(_e,"class","language-typescript"),y(Ce,"class","language-typescript"),y(Oe,"class","language-typescript"),y(Te,"class","language-typescript"),y(Ue,"class","language-typescript"),y(xe,"class","language-typescript"),y(Be,"class","language-typescript"),y(De,"class","language-typescript"),y(Ae,"class","language-typescript"),y(Pe,"class","language-typescript"),y(Ke,"class","language-typescript"),y(Le,"class","language-typescript"),y(Se,"class","language-typescript"),y(Re,"class","language-typescript"),y(je,"class","language-typescript"),y(Ve,"href","https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/"),y(Ve,"rel","nofollow"),y(Ie,"class","language-typescript"),y(Me,"class","language-typescript"),y(He,"class","language-typescript"),y(We,"class","language-typescript"),y(Fe,"class","language-typescript"),y(Qe,"href","https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence"),y(Qe,"rel","nofollow"),y(qe,"class","language-typescript"),y(Ge,"href","https://www.typescriptlang.org/play?ts=4.3.2#code/PTAEFUBcEsBtsgT1EgDgUwM4FgBQ6APVAewCdIVENQA1AQ1gFd0AeAIVLoDsATUQyOl6ZQmSKWhcA5gD5QAXlAAKMROmgAZKADeAfQBGnXgC5QHbjwC+ASlAAfUF0axY90I17oAZpPQ88eIQk5JTUAMqQdIIAYmQA0uiImCzgpLAJSfwEgsKi4pJSADRmRnwCQjwiqgVyitp4oKAA2gDWiaCSEGkZmAC6pvRMrOa8MniWDaABuCCgUtAAbuigALbLDK7EXigAFsttmVug3KDE+gBW6ADGFGjLAPKgAO470Fc7oDt0S6ALDMwiSBfCjlXiiYhrULLGiBIhkW5UZY9NiIQbMFiPUGVHSWYo0Wo6VrtToHI73fqge5ExC9LI5bE0UAAflAB1Api46CWpEs1LJvWms3mP0hQOWZ0uN1AXjIaz4R0wjHerMSOHwcJCd1AAAU3i0UWjWJjshURNpcbQCbqri0McVkaj-ka8TIxrhpngQFcISROVxIABBYB3TAAOkgathwQR1BGPADClAAHJvStfUJA0nplqegnFEmZcQk24k-o6KRiw5S3QAF5Z93q6NQrqwCJRdB50BtmLxVUsXPFOMBt2e4Cp9P+tjBxFhiPTILw5txtiJlM+4h+yBset4HOqlf5tiFyvJthlisls+1neNxda1KtyKCA9dp-oWKkHr9-eD0psEczGO66bgAwtOGCzpGt6aoiJQWCBq7jhuGYgTee5JAh+YgceJYgeeJ5Jnh17zhqMbLA+3boJhr7th+X49CBv7wQBHqAYwmDoA+2rlnQKxQfeaSUYmFFvgmWgie2K7iYJb4gdmsFxiIigSYIfLbCp6C0liZoGKUpiSF46CkHBvCWG4TguG4Hg8N4vh8Cycbso4XJGYKYBiqAqDlhQRweeAABKAAyeTtrsUSgPo6CwBuUiAsQ4KQoYFhRnesGUR+7ClHSpomZUVp6gaTopDJ7Z4kVcauqxswbrAyAHCIdCYJg0BSJyfCQPFKzODAqCwMsSW5E8cCuFijjOK4DjWbZbWhqAAAqrwiNADXNn1SyuKgpDEL5wK7EZ6ykMsXDxYqyr1aGeDelwYigLpFiYLoPAbpAujENysB0KgiZKJMjT1bojXNa1fi6B1uhdbAPV9XdwimA6hrFY+pVjZZk2eD4bUyMUeDWByLnGfIcj-YDLVtaDxDg910C9egMOVCRTZXTd7GcWk3GcHxiaZRY2W5IpMhKLjzTpWQ3OjMUSgZhIWCmOzMAMCwIukGLPCurYhO-MQ0A8LSGv1LgjQgAtyzQGmfVrP6UTQBupzbB5OzbS0HQiMdty7ZIgiHWIBTFDzACSoBPVwSYUC0x1PJ8xARx1gfxYddBSkCBRLVwxyeR9iBSFt1kXQboCHZAjCkKnFmuI1xxcIg4x4EAA"),y(Ge,"rel","nofollow")},m(e,r){c(e,k,r),t(k,W),t(k,I),t(I,me),t(k,m),c(e,U,r),c(e,M,r),t(M,lo),t(M,we),t(we,ro),t(M,co),c(e,fa,r),c(e,F,r),t(F,io),t(F,bt),t(bt,uo),t(F,ho),t(F,Et),t(Et,yo),t(F,ko),c(e,ma,r),c(e,Z,r),t(Z,gt),t(gt,fo),t(Z,mo),t(Z,_t),t(_t,wo),c(e,wa,r),c(e,Q,r),t(Q,vo),t(Q,Ct),t(Ct,bo),t(Q,Eo),t(Q,ve),t(ve,go),t(Q,_o),c(e,va,r),c(e,Ye,r),t(Ye,Co),c(e,ba,r),c(e,x,r),t(x,Oo),t(x,Ot),t(Ot,To),t(x,Uo),t(x,Tt),t(Tt,xo),t(x,Bo),t(x,Ut),t(Ut,Do),t(x,Ao),c(e,Ea,r),c(e,ze,r),t(ze,Po),c(e,ga,r),c(e,Ze,r),t(Ze,Ko),c(e,_a,r),c(e,be,r),be.innerHTML=Sh,c(e,Ca,r),c(e,N,r),t(N,Lo),t(N,xt),t(xt,So),t(N,Ro),c(e,Oa,r),c(e,Ee,r),Ee.innerHTML=Rh,c(e,Ta,r),c(e,X,r),t(X,jo),t(X,Bt),t(Bt,Vo),t(X,Io),c(e,Ua,r),c(e,ge,r),ge.innerHTML=jh,c(e,xa,r),c(e,B,r),t(B,Mo),t(B,Dt),t(Dt,Ho),t(B,Wo),t(B,At),t(At,Fo),t(B,Qo),t(B,Pt),t(Pt,qo),t(B,Go),c(e,Ba,r),c(e,_e,r),_e.innerHTML=Vh,c(e,Da,r),c(e,Ne,r),t(Ne,Jo),c(e,Aa,r),c(e,Xe,r),t(Xe,Yo),c(e,Pa,r),c(e,$e,r),t($e,zo),c(e,Ka,r),c(e,et,r),t(et,Zo),c(e,La,r),c(e,tt,r),t(tt,No),c(e,Sa,r),c(e,Ce,r),Ce.innerHTML=Ih,c(e,Ra,r),c(e,D,r),t(D,Xo),t(D,Kt),t(Kt,$o),t(D,ep),t(D,Lt),t(Lt,tp),t(D,sp),t(D,St),t(St,ap),t(D,np),c(e,ja,r),c(e,Oe,r),Oe.innerHTML=Mh,c(e,Va,r),c(e,st,r),t(st,op),c(e,Ia,r),c(e,Te,r),Te.innerHTML=Hh,c(e,Ma,r),c(e,at,r),t(at,pp),c(e,Ha,r),c(e,nt,r),t(nt,lp),c(e,Wa,r),c(e,Ue,r),Ue.innerHTML=Wh,c(e,Fa,r),c(e,ot,r),t(ot,rp),c(e,Qa,r),c(e,pt,r),t(pt,cp),c(e,qa,r),c(e,lt,r),t(lt,ip),c(e,Ga,r),c(e,xe,r),xe.innerHTML=Fh,c(e,Ja,r),c(e,C,r),t(C,Rt),t(Rt,up),t(C,hp),t(C,jt),t(jt,dp),t(C,yp),t(C,Vt),t(Vt,kp),t(C,fp),t(C,It),t(It,mp),t(C,wp),t(C,Mt),t(Mt,vp),t(C,bp),c(e,Ya,r),c(e,$,r),t($,Ep),t($,Ht),t(Ht,gp),t($,_p),c(e,za,r),c(e,Be,r),Be.innerHTML=Qh,c(e,Za,r),c(e,ee,r),t(ee,Cp),t(ee,Wt),t(Wt,Op),t(ee,Tp),c(e,Na,r),c(e,rt,r),t(rt,Up),c(e,Xa,r),c(e,te,r),t(te,xp),t(te,Ft),t(Ft,Bp),t(te,Dp),c(e,$a,r),c(e,De,r),De.innerHTML=qh,c(e,en,r),c(e,v,r),t(v,Ap),t(v,Qt),t(Qt,Pp),t(v,Kp),t(v,qt),t(qt,Lp),t(v,Sp),t(v,Gt),t(Gt,Rp),t(v,jp),t(v,Jt),t(Jt,Vp),t(v,Ip),t(v,Yt),t(Yt,Mp),t(v,Hp),c(e,tn,r),c(e,Ae,r),Ae.innerHTML=Gh,c(e,sn,r),c(e,z,r),t(z,zt),t(zt,Wp),t(z,Fp),t(z,Zt),t(Zt,Qp),t(z,qp),c(e,an,r),c(e,A,r),t(A,Gp),t(A,Nt),t(Nt,Jp),t(A,Yp),t(A,Xt),t(Xt,zp),t(A,Zp),t(A,$t),t($t,Np),t(A,Xp),c(e,nn,r),c(e,Pe,r),Pe.innerHTML=Jh,c(e,on,r),c(e,se,r),t(se,$p),t(se,es),t(es,el),t(se,tl),c(e,pn,r),c(e,ct,r),t(ct,sl),c(e,ln,r),c(e,Ke,r),Ke.innerHTML=Yh,c(e,rn,r),c(e,q,r),t(q,al),t(q,ts),t(ts,nl),t(q,ol),t(q,ss),t(ss,pl),t(q,ll),c(e,cn,r),c(e,it,r),t(it,rl),c(e,un,r),c(e,ae,r),t(ae,cl),t(ae,as),t(as,il),t(ae,ul),c(e,hn,r),c(e,Le,r),Le.innerHTML=zh,c(e,dn,r),c(e,b,r),t(b,hl),t(b,ns),t(ns,dl),t(b,yl),t(b,os),t(os,kl),t(b,fl),t(b,ps),t(ps,ml),t(b,wl),t(b,ls),t(ls,vl),t(b,bl),t(b,rs),t(rs,El),t(b,gl),c(e,yn,r),c(e,O,r),t(O,_l),t(O,cs),t(cs,Cl),t(O,Ol),t(O,is),t(is,Tl),t(O,Ul),t(O,us),t(us,xl),t(O,Bl),t(O,hs),t(hs,Dl),t(O,Al),c(e,kn,r),c(e,E,r),t(E,Pl),t(E,ds),t(ds,Kl),t(E,Ll),t(E,ys),t(ys,Sl),t(E,Rl),t(E,ks),t(ks,jl),t(E,Vl),t(E,fs),t(fs,Il),t(E,Ml),t(E,ms),t(ms,Hl),t(E,Wl),c(e,fn,r),c(e,Se,r),Se.innerHTML=Zh,c(e,mn,r),c(e,h,r),t(h,Fl),t(h,ws),t(ws,Ql),t(h,ql),t(h,vs),t(vs,Gl),t(h,Jl),t(h,bs),t(bs,Yl),t(h,zl),t(h,Es),t(Es,Zl),t(h,Nl),t(h,gs),t(gs,Xl),t(h,$l),t(h,_s),t(_s,er),t(h,tr),t(h,Cs),t(Cs,sr),t(h,ar),t(h,Os),t(Os,nr),t(h,or),t(h,Ts),t(Ts,pr),t(h,lr),t(h,Us),t(Us,rr),t(h,cr),t(h,xs),t(xs,ir),t(h,ur),t(h,Bs),t(Bs,hr),t(h,dr),t(h,Ds),t(Ds,yr),t(h,kr),t(h,As),t(As,fr),t(h,mr),t(h,Ps),t(Ps,wr),t(h,vr),t(h,Ks),t(Ks,br),t(h,Er),t(h,Ls),t(Ls,gr),t(h,_r),c(e,wn,r),c(e,g,r),t(g,Cr),t(g,Ss),t(Ss,Or),t(g,Tr),t(g,Rs),t(Rs,Ur),t(g,xr),t(g,js),t(js,Br),t(g,Dr),t(g,Vs),t(Vs,Ar),t(g,Pr),t(g,Is),t(Is,Kr),t(g,Lr),c(e,vn,r),c(e,ut,r),t(ut,Sr),c(e,bn,r),c(e,ht,r),t(ht,Rr),c(e,En,r),c(e,Re,r),Re.innerHTML=Nh,c(e,gn,r),c(e,f,r),t(f,Ms),t(Ms,jr),t(f,Vr),t(f,Hs),t(Hs,Ir),t(f,Mr),t(f,Ws),t(Ws,Hr),t(f,Wr),t(f,Fs),t(Fs,Fr),t(f,Qr),t(f,Qs),t(Qs,qr),t(f,Gr),t(f,qs),t(qs,Jr),t(f,Yr),t(f,Gs),t(Gs,zr),t(f,Zr),t(f,Js),t(Js,Nr),t(f,Xr),c(e,_n,r),c(e,je,r),je.innerHTML=Xh,c(e,Cn,r),c(e,ne,r),t(ne,$r),t(ne,Ve),t(Ve,ec),t(ne,tc),c(e,On,r),c(e,Ie,r),Ie.innerHTML=$h,c(e,Tn,r),c(e,oe,r),t(oe,sc),t(oe,Ys),t(Ys,ac),t(oe,nc),c(e,Un,r),c(e,Me,r),Me.innerHTML=ed,c(e,xn,r),c(e,pe,r),t(pe,oc),t(pe,zs),t(zs,pc),t(pe,lc),c(e,Bn,r),c(e,He,r),He.innerHTML=td,c(e,Dn,r),c(e,G,r),t(G,rc),t(G,Zs),t(Zs,cc),t(G,ic),t(G,Ns),t(Ns,uc),t(G,hc),c(e,An,r),c(e,le,r),t(le,dc),t(le,Xs),t(Xs,yc),t(le,kc),c(e,Pn,r),c(e,We,r),We.innerHTML=sd,c(e,Kn,r),c(e,re,r),t(re,fc),t(re,$s),t($s,mc),t(re,wc),c(e,Ln,r),c(e,dt,r),t(dt,vc),c(e,Sn,r),c(e,yt,r),t(yt,bc),c(e,Rn,r),c(e,ce,r),t(ce,Ec),t(ce,ea),t(ea,gc),t(ce,_c),c(e,jn,r),c(e,Fe,r),Fe.innerHTML=ad,c(e,Vn,r),c(e,P,r),t(P,Cc),t(P,ta),t(ta,Oc),t(P,Tc),t(P,sa),t(sa,Uc),t(P,xc),t(P,aa),t(aa,Bc),t(P,Dc),c(e,In,r),c(e,K,r),t(K,Ac),t(K,Qe),t(Qe,Pc),t(K,Kc),t(K,na),t(na,Lc),t(K,Sc),t(K,oa),t(oa,Rc),t(K,jc),c(e,Mn,r),c(e,kt,r),t(kt,Vc),c(e,Hn,r),c(e,qe,r),qe.innerHTML=nd,c(e,Wn,r),c(e,_,r),t(_,Ic),t(_,pa),t(pa,Mc),t(_,Hc),t(_,la),t(la,Wc),t(_,Fc),t(_,ra),t(ra,Qc),t(_,qc),t(_,ca),t(ca,Gc),t(_,Jc),t(_,ia),t(ia,Yc),t(_,zc),c(e,Fn,r),c(e,T,r),t(T,Zc),t(T,ua),t(ua,Nc),t(T,Xc),t(T,ha),t(ha,$c),t(T,ei),t(T,da),t(da,ti),t(T,si),t(T,ya),t(ya,ai),t(T,ni),c(e,Qn,r),c(e,ie,r),t(ie,oi),t(ie,Ge),t(Ge,pi),t(ie,li)},p:Id,d(e){e&&s(k),e&&s(U),e&&s(M),e&&s(fa),e&&s(F),e&&s(ma),e&&s(Z),e&&s(wa),e&&s(Q),e&&s(va),e&&s(Ye),e&&s(ba),e&&s(x),e&&s(Ea),e&&s(ze),e&&s(ga),e&&s(Ze),e&&s(_a),e&&s(be),e&&s(Ca),e&&s(N),e&&s(Oa),e&&s(Ee),e&&s(Ta),e&&s(X),e&&s(Ua),e&&s(ge),e&&s(xa),e&&s(B),e&&s(Ba),e&&s(_e),e&&s(Da),e&&s(Ne),e&&s(Aa),e&&s(Xe),e&&s(Pa),e&&s($e),e&&s(Ka),e&&s(et),e&&s(La),e&&s(tt),e&&s(Sa),e&&s(Ce),e&&s(Ra),e&&s(D),e&&s(ja),e&&s(Oe),e&&s(Va),e&&s(st),e&&s(Ia),e&&s(Te),e&&s(Ma),e&&s(at),e&&s(Ha),e&&s(nt),e&&s(Wa),e&&s(Ue),e&&s(Fa),e&&s(ot),e&&s(Qa),e&&s(pt),e&&s(qa),e&&s(lt),e&&s(Ga),e&&s(xe),e&&s(Ja),e&&s(C),e&&s(Ya),e&&s($),e&&s(za),e&&s(Be),e&&s(Za),e&&s(ee),e&&s(Na),e&&s(rt),e&&s(Xa),e&&s(te),e&&s($a),e&&s(De),e&&s(en),e&&s(v),e&&s(tn),e&&s(Ae),e&&s(sn),e&&s(z),e&&s(an),e&&s(A),e&&s(nn),e&&s(Pe),e&&s(on),e&&s(se),e&&s(pn),e&&s(ct),e&&s(ln),e&&s(Ke),e&&s(rn),e&&s(q),e&&s(cn),e&&s(it),e&&s(un),e&&s(ae),e&&s(hn),e&&s(Le),e&&s(dn),e&&s(b),e&&s(yn),e&&s(O),e&&s(kn),e&&s(E),e&&s(fn),e&&s(Se),e&&s(mn),e&&s(h),e&&s(wn),e&&s(g),e&&s(vn),e&&s(ut),e&&s(bn),e&&s(ht),e&&s(En),e&&s(Re),e&&s(gn),e&&s(f),e&&s(_n),e&&s(je),e&&s(Cn),e&&s(ne),e&&s(On),e&&s(Ie),e&&s(Tn),e&&s(oe),e&&s(Un),e&&s(Me),e&&s(xn),e&&s(pe),e&&s(Bn),e&&s(He),e&&s(Dn),e&&s(G),e&&s(An),e&&s(le),e&&s(Pn),e&&s(We),e&&s(Kn),e&&s(re),e&&s(Ln),e&&s(dt),e&&s(Sn),e&&s(yt),e&&s(Rn),e&&s(ce),e&&s(jn),e&&s(Fe),e&&s(Vn),e&&s(P),e&&s(In),e&&s(K),e&&s(Mn),e&&s(kt),e&&s(Hn),e&&s(qe),e&&s(Wn),e&&s(_),e&&s(Fn),e&&s(T),e&&s(Qn),e&&s(ie)}}}function Wd(Je){let k,W;const I=[Je[0],Lh];let me={$$slots:{default:[Hd]},$$scope:{ctx:Je}};for(let m=0;m<I.length;m+=1)me=ri(me,I[m]);return k=new Md({props:me}),{c(){Pd(k.$$.fragment)},l(m){Kd(k.$$.fragment,m)},m(m,U){Ld(k,m,U),W=!0},p(m,[U]){const M=U&1?Sd(I,[U&1&&Ph(m[0]),U&0&&Ph(Lh)]):{};U&2&&(M.$$scope={dirty:U,ctx:m}),k.$set(M)},i(m){W||(Rd(k.$$.fragment,m),W=!0)},o(m){jd(k.$$.fragment,m),W=!1},d(m){Vd(k,m)}}}const Lh={title:"Type Safe URL Wrangling in React",date:"2021-06-04T16:45:19.000Z",status:"published",blurb:"Search params in the URL are an underrated way to store state, but synchronizing access to them from multiple components can be tricky to type well."};function Fd(Je,k,W){return Je.$$set=I=>{W(0,k=ri(ri({},k),Kh(I)))},k=Kh(k),[k]}class Gd extends Bd{constructor(k){super(),Dd(this,k,Fd,Wd,Ad,{})}}export{Gd as default,Lh as metadata};
