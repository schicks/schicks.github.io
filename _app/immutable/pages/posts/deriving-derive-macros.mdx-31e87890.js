import{S as Js,i as Ks,s as Vs,D as Hn,x as Xs,y as Ys,z as eo,A as to,B as Bs,r as ao,p as no,C as so,Q as $s,e as o,t as n,k as u,c as l,a as p,h as s,d as a,m as f,b as m,g as r,H as t,n as oo}from"../../chunks/index-986541d7.js";import{B as lo}from"../../chunks/blog-0a461edf.js";function po(V){let c,D,_,B,h,v,X,St,$,At,Ht,he,Wt,Lt,ke,gt,Bt,Xe,Y,$t,Ye,q,ye,zt,jt,ve,Rt,et,ee,Ft,tt,te,Nt,at,z,js=`<code class="language-rust"><span class="token keyword">trait</span> <span class="token type-definition class-name">Monoid</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">fn</span> <span class="token function-definition function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span>

  <span class="token keyword">fn</span> <span class="token function-definition function">append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span>
<span class="token punctuation">&#125;</span></code>`,nt,ae,Ut,st,j,Rs=`<code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">T_is_a_monoid</span><span class="token punctuation">(</span>example<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> example<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">,</span> example<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,ot,I,Qt,we,Zt,Gt,_e,Jt,Kt,lt,d,Vt,Ee,Xt,Yt,be,ea,ta,Te,aa,na,De,sa,oa,Ie,la,pa,Ce,ia,ra,Oe,ca,ua,Pe,fa,da,pt,y,ma,xe,ha,ka,Me,ya,va,qe,wa,_a,Se,Ea,ba,Ae,Ta,Da,it,ne,R,Ia,F,Ca,Oa,rt,se,Pa,ct,oe,T,xa,N,Ma,qa,U,Sa,Aa,Q,Ha,Wa,ut,le,La,ft,Z,Fs=`<code class="language-rust"><span class="token keyword">trait</span> <span class="token type-definition class-name">MyTrait</span> <span class="token punctuation">&#123;</span>
  <span class="token function">my_trait_func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">ReturnType</span>
<span class="token punctuation">&#125;</span></code>`,dt,w,ga,He,Ba,$a,We,za,ja,Le,Ra,Fa,ge,Na,Ua,mt,S,Qa,Be,Za,Ga,ht,G,Ns=`<code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">impl_struct</span><span class="token punctuation">(</span> <span class="token comment">// arguments correspond to our assumptions.</span>
  input<span class="token punctuation">:</span> <span class="token class-name">DeriveInput</span><span class="token punctuation">,</span> <span class="token comment">// we have some struct</span>
  trait_name<span class="token punctuation">:</span> <span class="token class-name">Ident</span><span class="token punctuation">,</span> <span class="token comment">// that we want to derive a trait on.</span>
  trait_func_name<span class="token punctuation">:</span> <span class="token class-name">Ident</span><span class="token punctuation">,</span> <span class="token comment">// that trait can be implemented with one function.</span>
  return_type<span class="token punctuation">:</span> <span class="token class-name">Ident</span> <span class="token comment">// that function has some return type with monoidal structure</span>
<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">TokenStream</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> struct_name <span class="token operator">=</span> input<span class="token punctuation">.</span>ident<span class="token punctuation">;</span>
  <span class="token keyword">let</span> struct_fields <span class="token operator">=</span> <span class="token keyword">match</span> input<span class="token punctuation">.</span>data <span class="token punctuation">&#123;</span>
    <span class="token class-name">Data</span><span class="token punctuation">::</span><span class="token class-name">Struct</span><span class="token punctuation">(</span><span class="token class-name">DataStruct</span> <span class="token punctuation">&#123;</span>
      fields<span class="token punctuation">:</span> <span class="token class-name">Fields</span><span class="token punctuation">::</span><span class="token class-name">Named</span><span class="token punctuation">(</span>fields<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">..</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">=></span> fields<span class="token punctuation">.</span>named<span class="token punctuation">,</span>
    _ <span class="token operator">=></span> <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">"not a struct"</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> empty_value <span class="token operator">=</span> <span class="token macro property">quote!</span><span class="token punctuation">&#123;</span> #<span class="token namespace">return_type<span class="token punctuation">::</span></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> trait_func_impl <span class="token operator">=</span> fields
  <span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>field<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span> <span class="token comment">// for each field</span>
    <span class="token keyword">let</span> field_name <span class="token operator">=</span> field<span class="token punctuation">.</span>ident<span class="token punctuation">;</span>
    <span class="token macro property">quote!</span><span class="token punctuation">&#123;</span>#field_name<span class="token punctuation">.</span>#<span class="token function">trait_func_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token comment">// apply the trait function to get some instance of #return_type</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>empty_value<span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>accumulated_code<span class="token punctuation">,</span> field_result<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span> <span class="token comment">// then combine the results</span>
    <span class="token macro property">quote!</span><span class="token punctuation">&#123;</span>#<span class="token namespace">return_type<span class="token punctuation">::</span></span><span class="token function">append</span><span class="token punctuation">(</span>#accumulated_code<span class="token punctuation">,</span> #field_result<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token comment">// using the binary function from the monoid over #return_type</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token macro property">quote!</span><span class="token punctuation">&#123;</span>
    <span class="token attribute attr-name">#[automatically_derived]</span>
    <span class="token keyword">impl</span> #trait_name <span class="token keyword">for</span> #struct_name <span class="token punctuation">&#123;</span>
      <span class="token keyword">fn</span> #<span class="token function">trait_func_name</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> #return_type <span class="token punctuation">&#123;</span>
        #trait_func_impl
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,kt,pe,M,Ja,$e,Ka,Va,ze,Xa,Ya,yt,A,en,je,tn,an,vt,E,nn,Re,sn,on,Fe,ln,pn,Ne,rn,cn,wt,C,un,Ue,fn,dn,Qe,mn,hn,_t,H,kn,Ze,yn,vn,Et,ie,wn,bt,re,_n,Tt,W,Ge,En,bn,Je,Tn,Dt,O,Dn,J,In,Cn,Ke,On,Pn,It,P,xn,Ve,Mn,qn,K,Sn,An;return{c(){c=o("p"),D=n("Custom derive macros are used in a variety of rust libraries ("),_=o("a"),B=n("serde"),h=n(", "),v=o("a"),X=n("argh"),St=n(", and of course "),$=o("a"),At=n("sedk"),Ht=n(") to make it easy and obvious to implement some trait for structs and/or enums as long as all of the fields in that struct or enum implement the trait. Built in derives also tend to follow this pattern. We know that there is an obvious definition of "),he=o("code"),Wt=n("PartialEq"),Lt=n(" for a struct as long as there is a definition of "),ke=o("code"),gt=n("PartialEq"),Bt=n(" for each field; two structs are equal all of their fields are equal."),Xe=u(),Y=o("p"),$t=n("There is a more general pattern here. given any product type (struct) and a trait that can be implemented with a single function, we can come up with an easy implementation of a trait as long as:"),Ye=u(),q=o("ul"),ye=o("li"),zt=n("All fields in the type implement the trait"),jt=u(),ve=o("li"),Rt=n("the return type of the trait function has monoidal structure"),et=u(),ee=o("h2"),Ft=n("Monoidal Structure?"),tt=u(),te=o("p"),Nt=n("A monoid is a certain sort of structure that a type can have. We can sketch it with a trait."),at=u(),z=o("pre"),nt=u(),ae=o("p"),Ut=n("However, to truly be a monoid, implementing types would have to satisfy a few more restructions."),st=u(),j=o("pre"),ot=u(),I=o("p"),Qt=n("If we could run this test on every possible instance of the type "),we=o("code"),Zt=n("T"),Gt=n(", and it passed for all of them, we would have proven that "),_e=o("code"),Jt=n("T"),Kt=n(" is a monoid."),lt=u(),d=o("p"),Vt=n("Monoids are neat and come up frequently. Addition and multiplication are both monoids over numbers, with "),Ee=o("code"),Xt=n("0"),Yt=n(" and "),be=o("code"),ea=n("1"),ta=n(" as the return values of "),Te=o("code"),aa=n("empty"),na=n(" respectively. String concatenation is a monoid, with the empty string as the "),De=o("code"),sa=n("empty"),oa=n(" value. Booleans have two monoids; "),Ie=o("code"),la=n("and"),pa=n(" is a monoid with an empty value of "),Ce=o("code"),ia=n("true"),ra=n(", and "),Oe=o("code"),ca=n("or"),ua=n(" is a monoid with an empty value of "),Pe=o("code"),fa=n("false"),da=n("."),pt=u(),y=o("p"),ma=n("We need a monoid so that we can combine together the result of applying the trait function to each individual field into a single value for the whole struct. In the context of "),xe=o("code"),ha=n("PartialEq"),ka=n(", our derived implementation uses "),Me=o("code"),ya=n("and"),va=n(" as it\u2019s monoid; that is, the "),qe=o("code"),wa=n("eq"),_a=n(" function returns true if the "),Se=o("code"),Ea=n("eq"),ba=n(" comparison applied to "),Ae=o("em"),Ta=n("every"),Da=n(" field returns true."),it=u(),ne=o("p"),R=o("em"),Ia=n("For a more in depth explanation of what a monoid is, read "),F=o("a"),Ca=n("Bartosz Milewski\u2019s"),Oa=n(" excellent series on category theory for programmers."),rt=u(),se=o("h2"),Pa=n("Derivation for Structs"),ct=u(),oe=o("p"),T=o("em"),xa=n("If you haven\u2019t worked with derive macros before, I highly recommend "),N=o("a"),Ma=n("this blog post"),qa=n(" for a quick explanation and "),U=o("a"),Sa=n("this repo"),Aa=n(" for a more in depth walkthrough. The "),Q=o("a"),Ha=n("syn documentation"),Wa=n(" is also quite useful."),ut=u(),le=o("p"),La=n("Lets say I have some trait."),ft=u(),Z=o("pre"),dt=u(),w=o("p"),ga=n("There are implementations of "),He=o("code"),Ba=n("MyTrait"),$a=n(" for a variety of different things that we\u2019ll call \u201Cprimitives\u201D in the sense that they implement "),We=o("code"),za=n("MyTrait"),ja=n(" by hand. What we want is to come up with some obvious implementation of "),Le=o("code"),Ra=n("MyTrait"),Fa=n(" for any struct or enum made up of "),ge=o("code"),Na=n("impl MyTrait"),Ua=n(" fields."),mt=u(),S=o("p"),Qa=n("Structs are easy. We\u2019ve said that all of our fields must implement the trait. Then we just need to apply our monoidal function to the result, and a single object of type "),Be=o("code"),Za=n("ReturnType"),Ga=n(" falls out. voila, we have our implementation."),ht=u(),G=o("pre"),kt=u(),pe=o("p"),M=o("em"),Ja=n("Notice that when we run a fold in the macro, the produced code will simply nest this statement repeatedly; "),$e=o("code"),Ka=n("monoid(monoid(monoid(empty, a), b), c)"),Va=n(". We use the empty value so we don\u2019t have to worry about whether the struct actually has fields; an empty struct would just return "),ze=o("code"),Xa=n("#return_type::empty()"),Ya=n("."),yt=u(),A=o("p"),en=n("This will give us a working implementation of our trait. It might not be the implementation we want; maybe we don\u2019t care about every field, or need to consider fields in different ways. In fact, given this monoidal structure, there is a much simpler implementation that always works for any type; simply returning "),je=o("code"),tn=n("#return_type::empty()"),an=n("."),vt=u(),E=o("p"),nn=n("This implementation seems nicer than that to me, because it considers each field in a uniform way, and because it nicely captures the core of what things like serde and argh are doing with their derive macros. In fact, if we generalize this to support helper attributes which could replace "),Re=o("code"),sn=n("#trait_func_name"),on=n(" with some arbitrary other function on "),Fe=o("code"),ln=n("#field_name"),pn=n(" that could produce a "),Ne=o("code"),rn=n("#return_type"),cn=n(", this becomes much more flexible and could be useful in a variety of settings."),wt=u(),C=o("h2"),un=n("What if "),Ue=o("code"),fn=n("#return_type"),dn=n(" is "),Qe=o("code"),mn=n("Self"),hn=n("?"),_t=u(),H=o("p"),kn=n("This doesn\u2019t work as well, because "),Ze=o("code"),yn=n("Self"),vn=n(" means different things for each field and for the struct as a whole. However, if we look at the places where derive macros are common, they don\u2019t tend to have polymorphic return types. Instead they go to some consistent type with monoidal structure."),Et=u(),ie=o("h2"),wn=n("What about enums?"),bt=u(),re=o("p"),_n=n("In the enum case, we can do the same thing for each branch independently. As long as each variant could be derived in a way similar to above, we can derive the implementation for the enum to be"),Tt=u(),W=o("ul"),Ge=o("li"),En=n("a pattern match against the enum"),bn=u(),Je=o("li"),Tn=n("a natural implementation for the context of each branch"),Dt=u(),O=o("p"),Dn=n("However, I am less confident that the \u201Cnatural\u201D implementation I describe there is useful in the enum case. I think in general that you do want some way to consider the context of which branch you are under. For instance, Serde has a "),J=o("a"),In=n("variety of ways"),Cn=n(" that you can represent enums, and two of the three involve considering at least the "),Ke=o("em"),On=n("name"),Pn=n(" of the variant."),It=u(),P=o("p"),xn=n("Similar to the potential generalization of the struct approach, the enum version could be "),Ve=o("em"),Mn=n("much"),qn=n(" more useful with the addition of helper macros. Then each branch could be processed with a different monoid, and individual fields could be processed differently as above. However, that\u2019s way too much code to put in a blog post. I\u2019m not "),K=o("a"),Sn=n("Amos"),An=n("."),this.h()},l(e){c=l(e,"P",{});var i=p(c);D=s(i,"Custom derive macros are used in a variety of rust libraries ("),_=l(i,"A",{href:!0,rel:!0});var Wn=p(_);B=s(Wn,"serde"),Wn.forEach(a),h=s(i,", "),v=l(i,"A",{href:!0,rel:!0});var Ln=p(v);X=s(Ln,"argh"),Ln.forEach(a),St=s(i,", and of course "),$=l(i,"A",{href:!0,rel:!0});var gn=p($);At=s(gn,"sedk"),gn.forEach(a),Ht=s(i,") to make it easy and obvious to implement some trait for structs and/or enums as long as all of the fields in that struct or enum implement the trait. Built in derives also tend to follow this pattern. We know that there is an obvious definition of "),he=l(i,"CODE",{});var Bn=p(he);Wt=s(Bn,"PartialEq"),Bn.forEach(a),Lt=s(i," for a struct as long as there is a definition of "),ke=l(i,"CODE",{});var $n=p(ke);gt=s($n,"PartialEq"),$n.forEach(a),Bt=s(i," for each field; two structs are equal all of their fields are equal."),i.forEach(a),Xe=f(e),Y=l(e,"P",{});var zn=p(Y);$t=s(zn,"There is a more general pattern here. given any product type (struct) and a trait that can be implemented with a single function, we can come up with an easy implementation of a trait as long as:"),zn.forEach(a),Ye=f(e),q=l(e,"UL",{});var Ct=p(q);ye=l(Ct,"LI",{});var jn=p(ye);zt=s(jn,"All fields in the type implement the trait"),jn.forEach(a),jt=f(Ct),ve=l(Ct,"LI",{});var Rn=p(ve);Rt=s(Rn,"the return type of the trait function has monoidal structure"),Rn.forEach(a),Ct.forEach(a),et=f(e),ee=l(e,"H2",{});var Fn=p(ee);Ft=s(Fn,"Monoidal Structure?"),Fn.forEach(a),tt=f(e),te=l(e,"P",{});var Nn=p(te);Nt=s(Nn,"A monoid is a certain sort of structure that a type can have. We can sketch it with a trait."),Nn.forEach(a),at=f(e),z=l(e,"PRE",{class:!0});var Us=p(z);Us.forEach(a),nt=f(e),ae=l(e,"P",{});var Un=p(ae);Ut=s(Un,"However, to truly be a monoid, implementing types would have to satisfy a few more restructions."),Un.forEach(a),st=f(e),j=l(e,"PRE",{class:!0});var Qs=p(j);Qs.forEach(a),ot=f(e),I=l(e,"P",{});var ce=p(I);Qt=s(ce,"If we could run this test on every possible instance of the type "),we=l(ce,"CODE",{});var Qn=p(we);Zt=s(Qn,"T"),Qn.forEach(a),Gt=s(ce,", and it passed for all of them, we would have proven that "),_e=l(ce,"CODE",{});var Zn=p(_e);Jt=s(Zn,"T"),Zn.forEach(a),Kt=s(ce," is a monoid."),ce.forEach(a),lt=f(e),d=l(e,"P",{});var k=p(d);Vt=s(k,"Monoids are neat and come up frequently. Addition and multiplication are both monoids over numbers, with "),Ee=l(k,"CODE",{});var Gn=p(Ee);Xt=s(Gn,"0"),Gn.forEach(a),Yt=s(k," and "),be=l(k,"CODE",{});var Jn=p(be);ea=s(Jn,"1"),Jn.forEach(a),ta=s(k," as the return values of "),Te=l(k,"CODE",{});var Kn=p(Te);aa=s(Kn,"empty"),Kn.forEach(a),na=s(k," respectively. String concatenation is a monoid, with the empty string as the "),De=l(k,"CODE",{});var Vn=p(De);sa=s(Vn,"empty"),Vn.forEach(a),oa=s(k," value. Booleans have two monoids; "),Ie=l(k,"CODE",{});var Xn=p(Ie);la=s(Xn,"and"),Xn.forEach(a),pa=s(k," is a monoid with an empty value of "),Ce=l(k,"CODE",{});var Yn=p(Ce);ia=s(Yn,"true"),Yn.forEach(a),ra=s(k,", and "),Oe=l(k,"CODE",{});var es=p(Oe);ca=s(es,"or"),es.forEach(a),ua=s(k," is a monoid with an empty value of "),Pe=l(k,"CODE",{});var ts=p(Pe);fa=s(ts,"false"),ts.forEach(a),da=s(k,"."),k.forEach(a),pt=f(e),y=l(e,"P",{});var b=p(y);ma=s(b,"We need a monoid so that we can combine together the result of applying the trait function to each individual field into a single value for the whole struct. In the context of "),xe=l(b,"CODE",{});var as=p(xe);ha=s(as,"PartialEq"),as.forEach(a),ka=s(b,", our derived implementation uses "),Me=l(b,"CODE",{});var ns=p(Me);ya=s(ns,"and"),ns.forEach(a),va=s(b," as it\u2019s monoid; that is, the "),qe=l(b,"CODE",{});var ss=p(qe);wa=s(ss,"eq"),ss.forEach(a),_a=s(b," function returns true if the "),Se=l(b,"CODE",{});var os=p(Se);Ea=s(os,"eq"),os.forEach(a),ba=s(b," comparison applied to "),Ae=l(b,"EM",{});var ls=p(Ae);Ta=s(ls,"every"),ls.forEach(a),Da=s(b," field returns true."),b.forEach(a),it=f(e),ne=l(e,"P",{});var ps=p(ne);R=l(ps,"EM",{});var Ot=p(R);Ia=s(Ot,"For a more in depth explanation of what a monoid is, read "),F=l(Ot,"A",{href:!0,rel:!0});var is=p(F);Ca=s(is,"Bartosz Milewski\u2019s"),is.forEach(a),Oa=s(Ot," excellent series on category theory for programmers."),Ot.forEach(a),ps.forEach(a),rt=f(e),se=l(e,"H2",{});var rs=p(se);Pa=s(rs,"Derivation for Structs"),rs.forEach(a),ct=f(e),oe=l(e,"P",{});var cs=p(oe);T=l(cs,"EM",{});var L=p(T);xa=s(L,"If you haven\u2019t worked with derive macros before, I highly recommend "),N=l(L,"A",{href:!0,rel:!0});var us=p(N);Ma=s(us,"this blog post"),us.forEach(a),qa=s(L," for a quick explanation and "),U=l(L,"A",{href:!0,rel:!0});var fs=p(U);Sa=s(fs,"this repo"),fs.forEach(a),Aa=s(L," for a more in depth walkthrough. The "),Q=l(L,"A",{href:!0,rel:!0});var ds=p(Q);Ha=s(ds,"syn documentation"),ds.forEach(a),Wa=s(L," is also quite useful."),L.forEach(a),cs.forEach(a),ut=f(e),le=l(e,"P",{});var ms=p(le);La=s(ms,"Lets say I have some trait."),ms.forEach(a),ft=f(e),Z=l(e,"PRE",{class:!0});var Zs=p(Z);Zs.forEach(a),dt=f(e),w=l(e,"P",{});var x=p(w);ga=s(x,"There are implementations of "),He=l(x,"CODE",{});var hs=p(He);Ba=s(hs,"MyTrait"),hs.forEach(a),$a=s(x," for a variety of different things that we\u2019ll call \u201Cprimitives\u201D in the sense that they implement "),We=l(x,"CODE",{});var ks=p(We);za=s(ks,"MyTrait"),ks.forEach(a),ja=s(x," by hand. What we want is to come up with some obvious implementation of "),Le=l(x,"CODE",{});var ys=p(Le);Ra=s(ys,"MyTrait"),ys.forEach(a),Fa=s(x," for any struct or enum made up of "),ge=l(x,"CODE",{});var vs=p(ge);Na=s(vs,"impl MyTrait"),vs.forEach(a),Ua=s(x," fields."),x.forEach(a),mt=f(e),S=l(e,"P",{});var Pt=p(S);Qa=s(Pt,"Structs are easy. We\u2019ve said that all of our fields must implement the trait. Then we just need to apply our monoidal function to the result, and a single object of type "),Be=l(Pt,"CODE",{});var ws=p(Be);Za=s(ws,"ReturnType"),ws.forEach(a),Ga=s(Pt," falls out. voila, we have our implementation."),Pt.forEach(a),ht=f(e),G=l(e,"PRE",{class:!0});var Gs=p(G);Gs.forEach(a),kt=f(e),pe=l(e,"P",{});var _s=p(pe);M=l(_s,"EM",{});var ue=p(M);Ja=s(ue,"Notice that when we run a fold in the macro, the produced code will simply nest this statement repeatedly; "),$e=l(ue,"CODE",{});var Es=p($e);Ka=s(Es,"monoid(monoid(monoid(empty, a), b), c)"),Es.forEach(a),Va=s(ue,". We use the empty value so we don\u2019t have to worry about whether the struct actually has fields; an empty struct would just return "),ze=l(ue,"CODE",{});var bs=p(ze);Xa=s(bs,"#return_type::empty()"),bs.forEach(a),Ya=s(ue,"."),ue.forEach(a),_s.forEach(a),yt=f(e),A=l(e,"P",{});var xt=p(A);en=s(xt,"This will give us a working implementation of our trait. It might not be the implementation we want; maybe we don\u2019t care about every field, or need to consider fields in different ways. In fact, given this monoidal structure, there is a much simpler implementation that always works for any type; simply returning "),je=l(xt,"CODE",{});var Ts=p(je);tn=s(Ts,"#return_type::empty()"),Ts.forEach(a),an=s(xt,"."),xt.forEach(a),vt=f(e),E=l(e,"P",{});var g=p(E);nn=s(g,"This implementation seems nicer than that to me, because it considers each field in a uniform way, and because it nicely captures the core of what things like serde and argh are doing with their derive macros. In fact, if we generalize this to support helper attributes which could replace "),Re=l(g,"CODE",{});var Ds=p(Re);sn=s(Ds,"#trait_func_name"),Ds.forEach(a),on=s(g," with some arbitrary other function on "),Fe=l(g,"CODE",{});var Is=p(Fe);ln=s(Is,"#field_name"),Is.forEach(a),pn=s(g," that could produce a "),Ne=l(g,"CODE",{});var Cs=p(Ne);rn=s(Cs,"#return_type"),Cs.forEach(a),cn=s(g,", this becomes much more flexible and could be useful in a variety of settings."),g.forEach(a),wt=f(e),C=l(e,"H2",{});var fe=p(C);un=s(fe,"What if "),Ue=l(fe,"CODE",{});var Os=p(Ue);fn=s(Os,"#return_type"),Os.forEach(a),dn=s(fe," is "),Qe=l(fe,"CODE",{});var Ps=p(Qe);mn=s(Ps,"Self"),Ps.forEach(a),hn=s(fe,"?"),fe.forEach(a),_t=f(e),H=l(e,"P",{});var Mt=p(H);kn=s(Mt,"This doesn\u2019t work as well, because "),Ze=l(Mt,"CODE",{});var xs=p(Ze);yn=s(xs,"Self"),xs.forEach(a),vn=s(Mt," means different things for each field and for the struct as a whole. However, if we look at the places where derive macros are common, they don\u2019t tend to have polymorphic return types. Instead they go to some consistent type with monoidal structure."),Mt.forEach(a),Et=f(e),ie=l(e,"H2",{});var Ms=p(ie);wn=s(Ms,"What about enums?"),Ms.forEach(a),bt=f(e),re=l(e,"P",{});var qs=p(re);_n=s(qs,"In the enum case, we can do the same thing for each branch independently. As long as each variant could be derived in a way similar to above, we can derive the implementation for the enum to be"),qs.forEach(a),Tt=f(e),W=l(e,"UL",{});var qt=p(W);Ge=l(qt,"LI",{});var Ss=p(Ge);En=s(Ss,"a pattern match against the enum"),Ss.forEach(a),bn=f(qt),Je=l(qt,"LI",{});var As=p(Je);Tn=s(As,"a natural implementation for the context of each branch"),As.forEach(a),qt.forEach(a),Dt=f(e),O=l(e,"P",{});var de=p(O);Dn=s(de,"However, I am less confident that the \u201Cnatural\u201D implementation I describe there is useful in the enum case. I think in general that you do want some way to consider the context of which branch you are under. For instance, Serde has a "),J=l(de,"A",{href:!0,rel:!0});var Hs=p(J);In=s(Hs,"variety of ways"),Hs.forEach(a),Cn=s(de," that you can represent enums, and two of the three involve considering at least the "),Ke=l(de,"EM",{});var Ws=p(Ke);On=s(Ws,"name"),Ws.forEach(a),Pn=s(de," of the variant."),de.forEach(a),It=f(e),P=l(e,"P",{});var me=p(P);xn=s(me,"Similar to the potential generalization of the struct approach, the enum version could be "),Ve=l(me,"EM",{});var Ls=p(Ve);Mn=s(Ls,"much"),Ls.forEach(a),qn=s(me," more useful with the addition of helper macros. Then each branch could be processed with a different monoid, and individual fields could be processed differently as above. However, that\u2019s way too much code to put in a blog post. I\u2019m not "),K=l(me,"A",{href:!0,rel:!0});var gs=p(K);Sn=s(gs,"Amos"),gs.forEach(a),An=s(me,"."),me.forEach(a),this.h()},h(){m(_,"href","https://serde.rs/"),m(_,"rel","nofollow"),m(v,"href","https://github.com/google/argh"),m(v,"rel","nofollow"),m($,"href","https://github.com/schicks/sedk"),m($,"rel","nofollow"),m(z,"class","language-rust"),m(j,"class","language-rust"),m(F,"href","https://bartoszmilewski.com/2015/07/21/free-monoids/"),m(F,"rel","nofollow"),m(N,"href","https://blog.turbo.fish/proc-macro-simple-derive/"),m(N,"rel","nofollow"),m(U,"href","https://github.com/dtolnay/proc-macro-workshop"),m(U,"rel","nofollow"),m(Q,"href","https://docs.rs/syn/0.15.26/syn/"),m(Q,"rel","nofollow"),m(Z,"class","language-rust"),m(G,"class","language-rust"),m(J,"href","https://serde.rs/enum-representations.html"),m(J,"rel","nofollow"),m(K,"href","https://fasterthanli.me/articles/getting-in-and-out-of-trouble-with-rust-futures"),m(K,"rel","nofollow")},m(e,i){r(e,c,i),t(c,D),t(c,_),t(_,B),t(c,h),t(c,v),t(v,X),t(c,St),t(c,$),t($,At),t(c,Ht),t(c,he),t(he,Wt),t(c,Lt),t(c,ke),t(ke,gt),t(c,Bt),r(e,Xe,i),r(e,Y,i),t(Y,$t),r(e,Ye,i),r(e,q,i),t(q,ye),t(ye,zt),t(q,jt),t(q,ve),t(ve,Rt),r(e,et,i),r(e,ee,i),t(ee,Ft),r(e,tt,i),r(e,te,i),t(te,Nt),r(e,at,i),r(e,z,i),z.innerHTML=js,r(e,nt,i),r(e,ae,i),t(ae,Ut),r(e,st,i),r(e,j,i),j.innerHTML=Rs,r(e,ot,i),r(e,I,i),t(I,Qt),t(I,we),t(we,Zt),t(I,Gt),t(I,_e),t(_e,Jt),t(I,Kt),r(e,lt,i),r(e,d,i),t(d,Vt),t(d,Ee),t(Ee,Xt),t(d,Yt),t(d,be),t(be,ea),t(d,ta),t(d,Te),t(Te,aa),t(d,na),t(d,De),t(De,sa),t(d,oa),t(d,Ie),t(Ie,la),t(d,pa),t(d,Ce),t(Ce,ia),t(d,ra),t(d,Oe),t(Oe,ca),t(d,ua),t(d,Pe),t(Pe,fa),t(d,da),r(e,pt,i),r(e,y,i),t(y,ma),t(y,xe),t(xe,ha),t(y,ka),t(y,Me),t(Me,ya),t(y,va),t(y,qe),t(qe,wa),t(y,_a),t(y,Se),t(Se,Ea),t(y,ba),t(y,Ae),t(Ae,Ta),t(y,Da),r(e,it,i),r(e,ne,i),t(ne,R),t(R,Ia),t(R,F),t(F,Ca),t(R,Oa),r(e,rt,i),r(e,se,i),t(se,Pa),r(e,ct,i),r(e,oe,i),t(oe,T),t(T,xa),t(T,N),t(N,Ma),t(T,qa),t(T,U),t(U,Sa),t(T,Aa),t(T,Q),t(Q,Ha),t(T,Wa),r(e,ut,i),r(e,le,i),t(le,La),r(e,ft,i),r(e,Z,i),Z.innerHTML=Fs,r(e,dt,i),r(e,w,i),t(w,ga),t(w,He),t(He,Ba),t(w,$a),t(w,We),t(We,za),t(w,ja),t(w,Le),t(Le,Ra),t(w,Fa),t(w,ge),t(ge,Na),t(w,Ua),r(e,mt,i),r(e,S,i),t(S,Qa),t(S,Be),t(Be,Za),t(S,Ga),r(e,ht,i),r(e,G,i),G.innerHTML=Ns,r(e,kt,i),r(e,pe,i),t(pe,M),t(M,Ja),t(M,$e),t($e,Ka),t(M,Va),t(M,ze),t(ze,Xa),t(M,Ya),r(e,yt,i),r(e,A,i),t(A,en),t(A,je),t(je,tn),t(A,an),r(e,vt,i),r(e,E,i),t(E,nn),t(E,Re),t(Re,sn),t(E,on),t(E,Fe),t(Fe,ln),t(E,pn),t(E,Ne),t(Ne,rn),t(E,cn),r(e,wt,i),r(e,C,i),t(C,un),t(C,Ue),t(Ue,fn),t(C,dn),t(C,Qe),t(Qe,mn),t(C,hn),r(e,_t,i),r(e,H,i),t(H,kn),t(H,Ze),t(Ze,yn),t(H,vn),r(e,Et,i),r(e,ie,i),t(ie,wn),r(e,bt,i),r(e,re,i),t(re,_n),r(e,Tt,i),r(e,W,i),t(W,Ge),t(Ge,En),t(W,bn),t(W,Je),t(Je,Tn),r(e,Dt,i),r(e,O,i),t(O,Dn),t(O,J),t(J,In),t(O,Cn),t(O,Ke),t(Ke,On),t(O,Pn),r(e,It,i),r(e,P,i),t(P,xn),t(P,Ve),t(Ve,Mn),t(P,qn),t(P,K),t(K,Sn),t(P,An)},p:oo,d(e){e&&a(c),e&&a(Xe),e&&a(Y),e&&a(Ye),e&&a(q),e&&a(et),e&&a(ee),e&&a(tt),e&&a(te),e&&a(at),e&&a(z),e&&a(nt),e&&a(ae),e&&a(st),e&&a(j),e&&a(ot),e&&a(I),e&&a(lt),e&&a(d),e&&a(pt),e&&a(y),e&&a(it),e&&a(ne),e&&a(rt),e&&a(se),e&&a(ct),e&&a(oe),e&&a(ut),e&&a(le),e&&a(ft),e&&a(Z),e&&a(dt),e&&a(w),e&&a(mt),e&&a(S),e&&a(ht),e&&a(G),e&&a(kt),e&&a(pe),e&&a(yt),e&&a(A),e&&a(vt),e&&a(E),e&&a(wt),e&&a(C),e&&a(_t),e&&a(H),e&&a(Et),e&&a(ie),e&&a(bt),e&&a(re),e&&a(Tt),e&&a(W),e&&a(Dt),e&&a(O),e&&a(It),e&&a(P)}}}function io(V){let c,D;const _=[V[0],zs];let B={$$slots:{default:[po]},$$scope:{ctx:V}};for(let h=0;h<_.length;h+=1)B=Hn(B,_[h]);return c=new lo({props:B}),{c(){Xs(c.$$.fragment)},l(h){Ys(c.$$.fragment,h)},m(h,v){eo(c,h,v),D=!0},p(h,[v]){const X=v&1?to(_,[v&1&&Bs(h[0]),v&0&&Bs(zs)]):{};v&2&&(X.$$scope={dirty:v,ctx:h}),c.$set(X)},i(h){D||(ao(c.$$.fragment,h),D=!0)},o(h){no(c.$$.fragment,h),D=!1},d(h){so(c,h)}}}const zs={title:"Deriving Derive Macros with Monoids",date:"2021-04-20T00:00:00.000Z",status:"published",blurb:"Custom derive macros are used in a number of rust libraries to make it easy and obvious to implement some trait for structs as long as all of its fields also implement that trait."};function ro(V,c,D){return V.$$set=_=>{D(0,c=Hn(Hn({},c),$s(_)))},c=$s(c),[c]}class fo extends Js{constructor(c){super(),Ks(this,c,ro,io,Vs,{})}}export{fo as default,zs as metadata};
