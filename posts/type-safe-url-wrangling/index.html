<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Simon would have said</title>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.png" />
    <link rel="stylesheet" href="/global.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YS6BJ97BPH"></script>
    <script>
      window.dataLayer = window.dataLayer || []
      function gtag() {
        dataLayer.push(arguments)
      }
      gtag('js', new Date())

      gtag('config', 'G-YS6BJ97BPH')
    </script>
    <meta http-equiv="content-security-policy" content="">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/__layout.svelte-a075e7c9.css">
	<link rel="stylesheet" href="/_app/immutable/assets/blog-bb74b951.css">
	<link rel="modulepreload" href="/_app/immutable/start-44346cdb.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/index-986541d7.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/preload-helper-60cab3ee.js">
	<link rel="modulepreload" href="/_app/immutable/pages/__layout.svelte-e331525b.js">
	<link rel="modulepreload" href="/_app/immutable/pages/posts/type-safe-url-wrangling.mdx-107b86d9.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/blog-0a461edf.js">
  </head>

  <body>
    <div>


<header class="svelte-18lm2j2"><a href="/" class="big svelte-18lm2j2"><h1 class="svelte-18lm2j2">Simon would have said</h1></a>
  <div class="links svelte-18lm2j2"><span class="big svelte-18lm2j2"><a href="/resume" class="svelte-18lm2j2">Resume</a></span>
    <span class="big svelte-18lm2j2"><a href="/whos-simon" class="svelte-18lm2j2">Who&#39;s Simon? </a></span>
    <span class="small svelte-18lm2j2"><a href="/" class="svelte-18lm2j2"><img src="/_app/immutable/assets/cottage-a5c14d1f.svg" alt="Back to index" class="svelte-18lm2j2"></a></span>
    <span class="svelte-18lm2j2"><a href="https://github.com/schicks" class="svelte-18lm2j2"><img src="/_app/immutable/assets/github-6a9577cd.svg" alt="Github" style="height: 24px" class="svelte-18lm2j2"></a></span>
    <span class="svelte-18lm2j2"><a href="https://www.linkedin.com/in/sam-schick-868ab8ab/" class="svelte-18lm2j2"><img src="/_app/immutable/assets/linkedin-9636faf9.svg" alt="Linkedin" style="height: 24px" class="svelte-18lm2j2"></a></span>
    <span class="svelte-18lm2j2"><a href="/feed.xml" class="svelte-18lm2j2"><img src="/_app/immutable/assets/rss-5e9f88af.svg" alt="rss feed" class="svelte-18lm2j2"></a></span></div></header>
<div class="body svelte-18lm2j2"><article class="blog"><h2>Type Safe URL Wrangling in React</h2>
  <p>Search params in the URL are an underrated way to store state in react applications. While they can be somewhat less ergonomic than state from <code>useReducer</code>, they have the major advantage of being more directly accessible to the user. This enables things like allowing the user to share links to their particular state, or allowing bookmarks to “remember” state which would be forgotten on page reloads if it were stored within react. However, it is important to understand the various bumps and ugliness that come along with search params.</p>
<p>Because the user has direct access to them, it’s hard to make strong type guarantees about what you will find when decoding a URL, and so it is important to <a href="https://www.pluralsight.com/tech-blog/taming-dynamic-data-in-typescript/" rel="nofollow">parse values</a> whenever you pull them out of the URL.</p>
<p>Also, when multiple components in your application want to use search params you can run into race conditions that can be infuriating to debug. However, just because we can’t make type level guarantees about the <em>values</em> in the URL doesn’t mean we can’t make type level guarantees about the <em>keys</em>. What’s important here is to think carefully about what we want the type system to validate for us.
When multiple components use the URL search params:</p>
<ol><li>No two components should use the same keys (to avoid race conditions)</li>
<li>Each component should explicitly state which keys it uses (to make 1 possible)</li></ol>
<p>A word of caution; this involves a <em>lot</em> of fancy types; in fact, it’s very close to using every typescript language feature that I’m aware of, and several obscure patterns that aren’t baked into the language. The great and powerful Dan Vanderkam is <a href="https://effectivetypescript.com/2021/02/03/pet-peeves/" rel="nofollow">absolutely right</a> that fancy types should be used sparingly, and can end up making things more complicated than they need to be. However, they can also allow you to make really specific guarantees with the type system that go way beyond simple type errors and start to make the type system feel like a real extension of your test suite. Also, they make you feel like a sorcerer.</p>
<h2>Run time</h2>
<p>Since most of the work here is about getting the type system to verify these properties for us, the runtime side of this is fairly simple. We want to create a new hook <code>useUrlParams</code> which will centralize interacting with the URL. This will deserialize the URL into an object and expose a wrapped version of the react router <code>push</code> function that will take an object and only update those keys in the URL. <code>null</code> will be interpreted as removing a value. Centralizing access to the URL in this way helps us make sure that we are interacting with that state in a consistent way, and would be good practice even if we didn’t want the type guarantees. It gives us a single component which is responsible for mediating access to the state in the URL, so we don’t have to implement things like the wrapped push function in every single component.</p>
<h2>Type time</h2>
<p>This is the fun part. There’s a lot of fancy types involved, so first we’re going to present the whole thing together to see what the point is, and then we’re going to dig into some of the more complicated signatures. If there’s a signature you don’t understand, stick with me and I’ll try to name it and explain it a little further down.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Value<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span>_brand<span class="token operator">:</span> Brand<span class="token punctuation">&#125;</span>
<span class="token operator">|</span> <span class="token keyword">null</span>
<span class="token operator">|</span> <span class="token keyword">undefined</span>

<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">StateForKeys<span class="token operator">&lt;</span>UrlKeys <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span> Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>key <span class="token keyword">in</span> UrlKeys<span class="token punctuation">]</span><span class="token operator">:</span> Value<span class="token operator">&lt;</span>Brand<span class="token operator">></span>
<span class="token punctuation">&#125;</span>


<span class="token comment">// give me all of the keys of an object type O</span>
<span class="token comment">// which have values that extend some type V</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">KeysByValue<span class="token operator">&lt;</span><span class="token constant">O</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">O</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">O</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">V</span></span> <span class="token operator">?</span> key <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">O</span><span class="token punctuation">]</span>

<span class="token comment">// give me the object formed of such keys</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PickByValue<span class="token operator">&lt;</span><span class="token constant">O</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">O</span><span class="token punctuation">,</span> KeysByValue<span class="token operator">&lt;</span><span class="token constant">O</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">>></span></code><!-- HTML_TAG_END --></pre>
<p>Within a <code>types</code> file for each component that wants to consume the URL, create a state type.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> StateForKeys <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/useUrlParams/types'</span>

<span class="token comment">// Any string unique to each component</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Brand</span> <span class="token operator">=</span> <span class="token string">'componentBrand'</span>

<span class="token keyword">type</span> <span class="token class-name">Keys</span> <span class="token operator">=</span> <span class="token string">'union'</span> <span class="token operator">|</span> <span class="token string">'of'</span> <span class="token operator">|</span> <span class="token string">'url'</span> <span class="token operator">|</span> <span class="token string">'keys'</span>

<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> StateForKeys<span class="token operator">&lt;</span>Keys<span class="token punctuation">,</span> Brand<span class="token operator">></span></code><!-- HTML_TAG_END --></pre>
<p>Within the implementation file for <code>useUrlParams</code>, we create a unified representation of the URL state across all components. This is where we will get type errors if multiple components attempt to use the same key in the URL.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>UrlState <span class="token keyword">as</span> AUrlState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentA/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>UrlState <span class="token keyword">as</span> BUrlState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentB/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>UrlState <span class="token keyword">as</span> CUrlState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentC/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>PickByValue<span class="token punctuation">,</span> KeysByValue<span class="token punctuation">,</span> Value<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/useUrlParams/types'</span>

<span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> AUrlState <span class="token operator">&amp;</span> BUrlState <span class="token operator">&amp;</span> CUrlState



<span class="token comment">// Type of the state accessible by a particular brand</span>
<span class="token keyword">type</span> <span class="token class-name">StateFor<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> PickByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> Value<span class="token operator">&lt;</span>Brand<span class="token operator">>></span>

<span class="token comment">// only keys which are assigned to multiple brands will extend null | undefined.</span>
<span class="token comment">// Therefore this function has return type never</span>
<span class="token comment">// as long as no key is assigned to multiple brands.</span>
<span class="token keyword">const</span> _brands_dont_overlap <span class="token operator">=</span> <span class="token punctuation">(</span>
  keys_assigned_to_multiple_brands<span class="token operator">:</span> KeysByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=></span> keys_assigned_to_multiple_brands

<span class="token keyword">const</span> _url_state_conforms <span class="token operator">=</span> <span class="token punctuation">(</span>
  state<span class="token operator">:</span> UrlState
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> Value<span class="token operator">&lt;</span>Brands<span class="token operator">></span><span class="token punctuation">&#125;</span>  <span class="token operator">=></span> state

<span class="token keyword">export</span> <span class="token keyword">const</span> useUrlParams <span class="token operator">=</span> <span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  StateFor<span class="token operator">&lt;</span>Brand<span class="token operator">></span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span>entries<span class="token operator">:</span> Partial<span class="token operator">&lt;</span>StateFor<span class="token operator">&lt;</span>Brand<span class="token operator">>></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">]</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token operator">...</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<p>Finally, we can consume <code>useUrlParams</code> anywhere we want to access the URL. The important thing here is that because <code>useUrlParams</code> has a type parameter for <code>Brand</code>, any attempt to access a key outside of your brand will be a type error, and any attempt to write to a key outside of your brand will be a type error. This gives us static enforcement that components won’t be interfering with each others URL params.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>Brand<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'components/componentA/types'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span>useUrlParams<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> 'components<span class="token operator">/</span>useUrlParams

<span class="token keyword">const</span> <span class="token function-variable function">ComponentA</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>urlState<span class="token punctuation">,</span> push<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useUrlParams</span><span class="token generic class-name"><span class="token operator">&lt;</span>Brand<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>
</code><!-- HTML_TAG_END --></pre>
<p>That’s all that needs to go into each component file. The rest will be inferred by typescript.</p>
<h2>Fancy types</h2>
<p>This is all very nice, but I’m using a lot of generic types, mapped types, conditional types, and type level proofs. These things don’t come up very often in day to day code, and plenty of people use typescript to great effect without understanding them or even recognizing them. A lot of them are documented elsewhere, so mostly I’m going to give quick overviews here for how I’ve used them and give you the names you need to dig in further if you’re interested.</p>
<h3>Mapped types</h3>
<p>Mapped types let us derive new object types from old ones. For instance, when talking about the part of the URL that a single component needs we have a type that represents the union of keys the component is interested in. We want to get a type that is an object which maps those keys to values that could come out of the URL.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Keys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token string">'c'</span> <span class="token comment">// keys of interest</span>

<span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>Key <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<p>This syntax says that <code>UrlState</code> is an object type which has a key for each possible value of the <code>Keys</code> type, and that all of it’s keys are mapped to <code>string | null | undefined</code>. Then in runtime code we could use that type to know what we will be able to access;</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token comment">// return type will be inferred as string | null | undefined</span>
<span class="token keyword">const</span> <span class="token function-variable function">getA</span> <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> UrlState<span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>a

<span class="token comment">// this will cause a type error since nonsense can't satisfy the &#96;Keys&#96; type</span>
<span class="token keyword">const</span> getNonsense <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> UrlState<span class="token punctuation">)</span> state<span class="token punctuation">.</span>nonsense</code><!-- HTML_TAG_END --></pre>
<p>Mapped types can reference the type of their keys as values. This is useful but hard to explain without some more fancy types, so just keep it in mind for now.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Keys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token string">'c'</span>

<span class="token comment">// resolves to &#123;a: 'a', b: 'b', c: 'c'&#125;</span>
<span class="token keyword">type</span> <span class="token class-name">Identity</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>Key <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> Key <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<h3>Type indexing</h3>
<p>When you have a type which has keys and values (like mapped types), you can ‘index’ into that type just like you would at runtime, to get the type under a particular key.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IdMapping</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  a<span class="token operator">:</span> <span class="token string">'id_a'</span>
  b<span class="token operator">:</span> <span class="token string">'id_b'</span>
  c<span class="token operator">:</span> <span class="token string">'id_c'</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 'id_a'</span>
<span class="token keyword">type</span> <span class="token class-name">IdA</span> <span class="token operator">=</span> IdMapping<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span>

<span class="token comment">// 'id_a' | 'id_b' | 'id_c'</span>
<span class="token keyword">type</span> <span class="token class-name">Ids</span> <span class="token operator">=</span> IdMapping<span class="token punctuation">[</span><span class="token keyword">keyof</span> IdMapping<span class="token punctuation">]</span></code><!-- HTML_TAG_END --></pre>
<p>This makes it much easier to work with mapped types to do a variety of flexible things.</p>
<h3>Intersection types</h3>
<p>Intersection types are a way to talk about values which satisfy both of two distinct types.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> both<span class="token operator">:</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token string">'hello!'</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<p><code>A</code> describes things which map a key <code>a</code> to a number, and <code>B</code> describes things which map a key <code>b</code> to a string. Of course, it’s not hard to imagine a value that does both of these things, and the intersection operator <code>&amp;</code> lets us construct the type of such things.</p>
<p>Like type indexing, this is rarely useful on it’s own. But it does let us combine things that should be defined separately in a straightforward way. In the code above, one of the ways we use this is to construct the <code>UrlState</code> type by intersecting together the types provided by each of the individual components.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> AUrlState <span class="token operator">&amp;</span> BUrlState <span class="token operator">&amp;</span> CUrlState</code><!-- HTML_TAG_END --></pre>
<p>We did this so that we could define each of the component states in their own file, somewhere close to the component, and defer combining them together until we were writing the central <code>useUrlParams</code> component.</p>
<h3>Generic types</h3>
<p>Generic types let us talk about whole sets of types that have the same structure. For instance, we want to be able to talk about something like <code>UrlState</code> for each component that needs to access the URL. We can do this with a generic type.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">StateForKeys<span class="token operator">&lt;</span>Keys <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<p>This looks a lot like the <code>UrlState</code> type above, except for that stuff in angle brackets; <code>&lt;Keys extends string&gt;</code>. This is called a <em>type parameter</em>. It acts a bit like an argument list, in the sense that it introduces the name of a new type <code>Keys</code> which can then be referenced on the other side of the equals sign. When we want to get a concrete type, we use angle brackets again to specify what the particular type of <code>Keys</code> should be.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">MyKeys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token string">'c'</span>
<span class="token keyword">type</span> <span class="token class-name">UrlState</span> <span class="token operator">=</span> StateForKeys<span class="token operator">&lt;</span>MyKeys<span class="token operator">></span></code><!-- HTML_TAG_END --></pre>
<p><code>UrlState</code> defined this way will be exactly the same as <code>UrlState</code> above, but just like functions allow us to reuse code, generics allow us to reuse types.</p>
<p>Type parameters can also have restrictions on them to specify that they can’t be any type, but have to satisfy some particular bound. In our example above, <code>&lt;Keys extends string&gt;</code> says that any parameter provided for <code>Keys</code> must only have values which are also values of the <code>string</code> type.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">BadKeys</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token number">4</span>
<span class="token keyword">type</span> <span class="token class-name">AlsoBad</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token string">'c'</span></code><!-- HTML_TAG_END --></pre>
<p>Both of these types have some values which are not strings, and so trying to use them as a parameter to <code>StateForKeys</code> would result in a type error. In that sense, these restrictions are like type signatures on normal runtime functions.</p>
<p>Combining this with type indexing, we could create a generic type which gives us the values of any object.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Values<span class="token operator">&lt;</span>Object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span></span> <span class="token operator">=</span> Object<span class="token punctuation">[</span><span class="token keyword">keyof</span> Object<span class="token punctuation">]</span></code><!-- HTML_TAG_END --></pre>
<p>This says that given any type <code>Object</code> which can have keys and values, we want the result of indexing into <code>Object</code> with any of its keys. In other words, the union of all its values.</p>
<h3>Conditional types</h3>
<p>Conditional types let us check something about a type and result in a different type depending on that check, just like ternaries do at runtime. For instance, in the full code above we have a <code>KeysByValue</code> type which we use to get all of the keys of an object type which are mapped to certain sorts of values.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">KeysByValue<span class="token operator">&lt;</span>Object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> Value<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token keyword">keyof</span> Object<span class="token punctuation">]</span><span class="token operator">:</span> Object<span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Value</span> <span class="token operator">?</span> Key <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> Object<span class="token punctuation">]</span></code><!-- HTML_TAG_END --></pre>
<p>This builds on both of the thigns we discussed above and introduces some new ones, so lets break it down. <code>KeysByValue</code> is a generic type, because it has type parameters; <code>&lt;Object extends {}, Value&gt;</code>. This means that on the other side of the equals sign we will be able to reference <code>Object</code>, which we know <code>extends {}</code>. That means it can be anything at all as long as that thing can have keys and values. We will also be able to reference <code>Value</code>, which has no restrictions at all.</p>
<p>On the other side of the equals sign we define <code>KeysByValue</code> as a mapped type. Before the colon we have <code>[Key in keyof Object]</code>. <code>keyof Object</code> means that the keys of this type will be the same as the keys of whatever we supply as the <code>Object</code> type.</p>
<p>After the colon we have our conditional type, <code>Object[Key] extends Value ? Key : never</code>. This looks a lot like a ternary, and can be interpreted in a very similar way. First, we have our condition; <code>Object[Key] extends Value</code>. In english, this will be true if the value of the type <code>Object</code> indexed by something of the type <code>Key</code> satisfies the type <code>Value</code>.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Mapping</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  a<span class="token operator">:</span> <span class="token builtin">boolean</span>
  b<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// resolves to 'no'</span>
<span class="token keyword">type</span> <span class="token class-name">Conditional</span> <span class="token operator">=</span> Mapping<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token string">'yes'</span> <span class="token operator">:</span> <span class="token string">'no'</span>

<span class="token comment">// resolves to 1 | 2 | 3</span>
<span class="token keyword">type</span> <span class="token class-name">OtherConditional</span> <span class="token operator">=</span> mapping<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> mapping<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span></code><!-- HTML_TAG_END --></pre>
<p>In our <code>KeysByValue</code> type, we check whether the value of <code>Object</code> at <code>Key</code> extends <code>Value</code>, and if it does we give back the type <code>Key</code>. If it doesn’t we give back <code>never</code>. <code>never</code> is a special type which has no values. That is, there is no thing at runtime that can be typed as <code>never</code>. The reason that is useful is that anything unioned with <code>never</code> is just itself; <code>number | never</code> is <code>number</code>, <code>string | never</code> is <code>string</code>, etc.
That is useful here because the last thing we do is index into the whole mapped type by <code>keyof Object</code> to get the union of all of the mapped values. Any of the values which get mapped to <code>never</code> just disappear, so what we’re left with is a union of the <em>subset</em> of keys which have values that extend <code>Value</code>.</p>
<p>So in english, <code>KeysByValue</code> says that for any <code>Object</code> type and <code>Value</code> type, it gives back the union of all keys which are mapped to something that <code>extends Value</code>. Conditional types are harder to grasp than a lot of the other fancy types, because they are <em>extremely</em> situational, so think about what this does for us in the URL example. We use this to tell apart the keys used by various different components based on their brand. But what’s a brand?</p>
<h3>Branded types</h3>
<p>All of our fancy types so far have been language features of typescript. Branded types are a little different. Branding is a pattern used to prevent typescript from recognizing two types as the same.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TempC</span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> <span class="token string">'degrees-celcius'</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<p><code>TempC</code> is the <em>intersection</em> of <code>number</code> and <code>{_brand: &#39;degrees-celcius&#39;}</code>. Intersection types are interpreted as being <em>both</em> of the things on either side of the <code>&amp;</code>. So <code>TempC</code> can be used whenever a number could be used, and also whenever <code>{_brand: &#39;degrees-celcius&#39;}</code> could be used. However, at runtime this is a pretty challenging thing to create, and involves casting a number into the branded type.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">const</span> freezing <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">as</span> TempC</code><!-- HTML_TAG_END --></pre>
<p>Branding is often used to <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" rel="nofollow">restrict the usage of a value</a> to the context where it makes sense. We use them a little differently in the URL example. Instead, we’re leaning on the fact that branded types don’t extend each other.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TempC</span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> <span class="token string">'degrees-c'</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> <span class="token class-name">TempF</span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> <span class="token string">'degrees-f'</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> <span class="token class-name">TempCExtendsNumber</span> <span class="token operator">=</span> TempC <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//true</span>
<span class="token keyword">type</span> <span class="token class-name">TempFExtendsNumber</span> <span class="token operator">=</span> TempF <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//true</span>
<span class="token keyword">type</span> <span class="token class-name">TempCIsNotTempF</span> <span class="token operator">=</span> TempC <span class="token keyword">extends</span> <span class="token class-name">TempF</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//false!</span></code><!-- HTML_TAG_END --></pre>
<p>Branded types extend their underlying type, but they don’t extend each other. This is especially useful in the context of our <code>KeysByValue</code> type, because if our values are branded we can retrieve all of the things with a particular brand.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ThermometerUnits</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  home<span class="token operator">:</span> TempC
  car<span class="token operator">:</span> TempC
  school<span class="token operator">:</span> TempF
<span class="token punctuation">&#125;</span>

<span class="token comment">// 'home' | 'school'</span>
<span class="token keyword">type</span> <span class="token class-name">CelsiusThermometers</span> <span class="token operator">=</span> KeysByValue<span class="token operator">&lt;</span>ThermometerUnits<span class="token punctuation">,</span> TempC<span class="token operator">></span></code><!-- HTML_TAG_END --></pre>
<p>In our URL use case we use brands to identify all of the keys that come from a particular component. In fact, we define a <code>Value</code> type for what values can be retrieved from a URL that has to carry a brand.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Value<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> _brand<span class="token operator">:</span> Brand <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span></code><!-- HTML_TAG_END --></pre>
<p>This says that given some branding string, values in the URL are either a branded string (<code>string &amp; {_brand: Brand}</code>) or they are null or undefined. This is a little quirky, but the structure there is necessary becase null and undefined <em>cannot</em> be branded.</p>
<p>We then use this branding of values to define a type which gives us the slice of the state accessible to a given component, which is what powers the signature of <code>useUrlParams</code>.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token comment">// Type of the state accessible by a particular brand</span>
<span class="token keyword">type</span> <span class="token class-name">StateFor<span class="token operator">&lt;</span>Brand <span class="token keyword">extends</span> Brands<span class="token operator">></span></span> <span class="token operator">=</span> PickByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> Value<span class="token operator">&lt;</span>Brand<span class="token operator">>></span></code><!-- HTML_TAG_END --></pre>
<p>This has real value, in that it makes sure that a component only accesses the keys that it claims it will access. But that’s not all I claimed that this URL code could do; I also said that if two components both tried to claim the same key, that would cause a type error. To get that guarantee we need <em>one</em> more fancy type.</p>
<h3>Type level proofs</h3>
<p>One way to think about typescript is that it is a system that lets you specify additional information about your javascript code to identify (in the form of type errors) when that code does something that you think should be illegal. Usually this is things like adding a number to an object, or trying to access a key that doesn’t exist. However, sometimes we want to be able to specify other sorts of restrictions that are not traditionally thought of as type errors.</p>
<p>For instance, the way this code is set up each individual component makes up a state type that gets intersectioned in to the overall URL state. We assume that this is done correctly, and that each component provides a state type that maps string keys to branded values. But what if we wanted to make it so that there would be a type error if we had done this wrong? What we want is something that will cause a type error if (and only if) the URL state doesn’t extend <code>{[Key in string]: Value&lt;Brands&gt;}</code>. It turns out, what we want is a function.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token keyword">const</span> _url_state_conforms <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> UrlState<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> Value<span class="token operator">&lt;</span>Brands<span class="token operator">></span> <span class="token punctuation">&#125;</span> <span class="token operator">=></span> state</code><!-- HTML_TAG_END --></pre>
<p>This function says that given any argument of type <code>UrlState</code>, it will return the type we want, and is implemented as the identity function; that is, it just returns its argument without modification. What that must mean is that any object which is of type <code>UrlState</code> is also of type <code>{[Key in string]: Value&lt;Brands&gt;}</code>, because if that weren’t true we would get a type error showing us where this might fail.</p>
<p>I call functions of this form “type level proofs”, because of some very <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="nofollow">esoteric</a> mathematics, but another way to think about them is type level <em>tests</em>. Just like tests, these are functions which are not used in production code, and only exist to verify that the code we have written satisfies some constraint. The main difference is that rather than the constraint being a runtime assertion, it happens at type time and can prove that something is true for <em>any possible argument</em>, rather than just the examples we happen to test.</p>
<p>Now, to sum it all up, we want to guarantee that there are no keys which are used by multiple different components.</p>
<pre class="language-typescript"><!-- HTML_TAG_START --><code class="language-typescript"><span class="token comment">// only keys which are assigned to multiple brands will extend null | undefined.</span>
<span class="token comment">// Therefore this function has return type never</span>
<span class="token comment">// as long as no key is assigned to multiple brands.</span>
<span class="token keyword">const</span> _brands_dont_overlap <span class="token operator">=</span> <span class="token punctuation">(</span>
  keys_assigned_to_multiple_brands<span class="token operator">:</span> KeysByValue<span class="token operator">&lt;</span>UrlState<span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=></span> keys_assigned_to_multiple_brands</code><!-- HTML_TAG_END --></pre>
<p>Same basic thing; an identity function with some input type and some output type. Here, we are using the function to check that anything of type <code>KeysByValue&lt;UrlState, null | undefined&gt;</code> (keys of <code>UrlState</code> which are mapped to <code>null | undefined</code> rather than being mapped to <code>Value&lt;Brand&gt;</code>) is of type <code>never</code>.</p>
<p>That’s a little strange, since <code>never</code> is defined as a type which has no values. Then another way to interpret this function is that it is claiming that there are <em>no values</em> which satisfy <code>KeysByValue&lt;UrlState, null | undefined&gt;</code>. Since a key would satisfy that type if and only if it had been assigned to multiple brands, this will cause a type error if there is any key with multiple brands because the return type will be the union of such keys rather than <code>never</code>.</p>
<p>That’s it! those are all of the tools we use to get our guarantees. We use a type level proof to show that no two components register the same keys, and we use branding to guarantee that each component only accesses the keys that it registered. Now that you’ve seen all of the fanciness, it’s worth going back through the code at the top and seeing if the complex signatures make more sense now. I’ve also set up a <a href="https://www.typescriptlang.org/play?ts=4.3.2#code/PTAEFUBcEsBtsgT1EgDgUwM4FgBQ6APVAewCdIVENQA1AQ1gFd0AeAIVLoDsATUQyOl6ZQmSKWhcA5gD5QAXlAAKMROmgAZKADeAfQBGnXgC5QHbjwC+ASlAAfUF0axY90I17oAZpPQ88eIQk5JTUAMqQdIIAYmQA0uiImCzgpLAJSfwEgsKi4pJSADRmRnwCQjwiqgVyitp4oKAA2gDWiaCSEGkZmAC6pvRMrOa8MniWDaABuCCgUtAAbuigALbLDK7EXigAFsttmVug3KDE+gBW6ADGFGjLAPKgAO470Fc7oDt0S6ALDMwiSBfCjlXiiYhrULLGiBIhkW5UZY9NiIQbMFiPUGVHSWYo0Wo6VrtToHI73fqge5ExC9LI5bE0UAAflAB1Api46CWpEs1LJvWms3mP0hQOWZ0uN1AXjIaz4R0wjHerMSOHwcJCd1AAAU3i0UWjWJjshURNpcbQCbqri0McVkaj-ka8TIxrhpngQFcISROVxIABBYB3TAAOkgathwQR1BGPADClAAHJvStfUJA0nplqegnFEmZcQk24k-o6KRiw5S3QAF5Z93q6NQrqwCJRdB50BtmLxVUsXPFOMBt2e4Cp9P+tjBxFhiPTILw5txtiJlM+4h+yBset4HOqlf5tiFyvJthlisls+1neNxda1KtyKCA9dp-oWKkHr9-eD0psEczGO66bgAwtOGCzpGt6aoiJQWCBq7jhuGYgTee5JAh+YgceJYgeeJ5Jnh17zhqMbLA+3boJhr7th+X49CBv7wQBHqAYwmDoA+2rlnQKxQfeaSUYmFFvgmWgie2K7iYJb4gdmsFxiIigSYIfLbCp6C0liZoGKUpiSF46CkHBvCWG4TguG4Hg8N4vh8Cycbso4XJGYKYBiqAqDlhQRweeAABKAAyeTtrsUSgPo6CwBuUiAsQ4KQoYFhRnesGUR+7ClHSpomZUVp6gaTopDJ7Z4kVcauqxswbrAyAHCIdCYJg0BSJyfCQPFKzODAqCwMsSW5E8cCuFijjOK4DjWbZbWhqAAAqrwiNADXNn1SyuKgpDEL5wK7EZ6ykMsXDxYqyr1aGeDelwYigLpFiYLoPAbpAujENysB0KgiZKJMjT1bojXNa1fi6B1uhdbAPV9XdwimA6hrFY+pVjZZk2eD4bUyMUeDWByLnGfIcj-YDLVtaDxDg910C9egMOVCRTZXTd7GcWk3GcHxiaZRY2W5IpMhKLjzTpWQ3OjMUSgZhIWCmOzMAMCwIukGLPCurYhO-MQ0A8LSGv1LgjQgAtyzQGmfVrP6UTQBupzbB5OzbS0HQiMdty7ZIgiHWIBTFDzACSoBPVwSYUC0x1PJ8xARx1gfxYddBSkCBRLVwxyeR9iBSFt1kXQboCHZAjCkKnFmuI1xxcIg4x4EAA" rel="nofollow">playground</a> where you can play around with a minimal version of the complete product, to see where type errors would appear if you break those guarantees and to see if you can get this to be any less eldritch nonsense than my version.</p></article>

<script src="https://utteranc.es/client.js" repo="schicks/schicks.github.io" issue-term="Type Safe URL Wrangling in React" label="blog-comments" theme="preferred-color-scheme" crossorigin="anonymous" async></script>
</div>


		<script type="module" data-sveltekit-hydrate="bl0ezh">
		import { start } from "/_app/immutable/start-44346cdb.js";
		start({
			target: document.querySelector('[data-sveltekit-hydrate="bl0ezh"]').parentNode,
			paths: {"base":"","assets":""},
			session: (function(a,b){return {posts:[{title:"Unifying API representations in Typescript",date:1730505600000,status:a,blurb:"Many different typescript libraries have very similar APIs. We can stitch them together by thinking about them as representations of data.",slug:"representation-apis"},{title:"Req: Postman in the terminal",date:1655393672000,status:a,blurb:"Postman is great, but we could do better.",slug:"release-announcement-req"},{title:"Visualizing Voting Systems: Plurality vs Approval Voting",date:1623836732000,status:a,blurb:"Visualizing our voting systems can help give us a sense of how the questions each system asks shape the answers we get. By playing around with what happens depending on where candidates are relative to each other, you can get a sense of what incentives our voting system gives to the people we elect.",slug:"visualizing-voting-systems"},{title:"Static rendering in Sveltekit",date:1623753870000,status:a,blurb:"Sveltekit endpoints can shift chart rendering from runtime to compile time for more accessible websites.",slug:"static-rendering-in-sveltekit"},{title:"Type Safe URL Wrangling in React",date:1622825119000,status:a,blurb:"Search params in the URL are an underrated way to store state, but synchronizing access to them from multiple components can be tricky to type well.",slug:"type-safe-url-wrangling"},{title:"Deriving Derive Macros with Monoids",date:b,status:a,blurb:"Custom derive macros are used in a number of rust libraries to make it easy and obvious to implement some trait for structs as long as all of its fields also implement that trait.",slug:"deriving-derive-macros"},{title:"Koka vs the World",date:b,status:a,blurb:"I love statically typed functional programming. Building up programs in statically typed functional style feels like a conversation with the compiler about what is possible. Python fanatics tell me over and over that you can't prototype that way. Unfortunately, heartbreakingly, sometimes they're right.",slug:"koka-vs-the-world"},{title:"Tree Traversals in Typescript",date:b,status:a,blurb:"In a search engine, we might want to be able to slice and dice the search results that came back by three different facets; by content type, by content level, and by timeframe.",slug:"typescript-tree-traversals"},{title:"Better Pooled Coronavirus Testing",date:1598400000000,status:a,blurb:"We need to be doing more Coronavirus testing, but it is hard to scale up the number of tests we can run in a day. One way the CDC is recommending getting around this restriction is by pooling tests.",slug:"better-pooled-coronavirus-testing"}]}}("published",1618876800000)),
			route: false,
			spa: false,
			trailing_slash: "always",
			hydrate: {
				status: 200,
				error: null,
				nodes: [0, 11],
				params: {},
				routeId: "posts/type-safe-url-wrangling"
			}
		});
	</script></div>
  </body>
</html>
